{"questionTitle": "Check if all elements in a list are identical", "question": "<p>I need a function which takes in a <code>list</code> and outputs <code>True</code> if all elements in the input list evaluate as equal to each other using the standard equality operator and <code>False</code> otherwise.</p>\n<p>I feel it would be best to iterate through the list comparing adjacent elements and then <code>AND</code> all the resulting Boolean values. But I'm not sure what's the most Pythonic way to do that.</p>\n", "acceptedAnswer": "<p>Use <a href=\"https://docs.python.org/3/library/itertools.html#itertools.groupby\" rel=\"noreferrer\"><code>itertools.groupby</code></a> (see <a href=\"https://docs.python.org/3/library/itertools.html#itertools-recipes\" rel=\"noreferrer\">the <code>itertools</code> recipes</a>):</p>\n<pre><code>from itertools import groupby\n\ndef all_equal(iterable):\n    g = groupby(iterable)\n    return next(g, True) and not next(g, False)\n</code></pre>\n<p>or without <code>groupby</code>:</p>\n<pre><code>def all_equal(iterator):\n    iterator = iter(iterator)\n    try:\n        first = next(iterator)\n    except StopIteration:\n        return True\n    return all(first == x for x in iterator)\n</code></pre>\n<hr />\n<p>There are a number of alternative one-liners you might consider:</p>\n<ol>\n<li><p>Converting the input to a set and checking that it only has one or zero (in case the input is empty) items</p>\n<pre><code>def all_equal2(iterator):\n    return len(set(iterator)) &lt;= 1\n</code></pre>\n</li>\n<li><p>Comparing against the input list without the first item</p>\n<pre><code>def all_equal3(lst):\n    return lst[:-1] == lst[1:]\n</code></pre>\n</li>\n<li><p><a href=\"http://stackoverflow.com/q/3844948/\">Counting how many times the first item appears in the list</a></p>\n<pre><code>def all_equal_ivo(lst):\n    return not lst or lst.count(lst[0]) == len(lst)\n</code></pre>\n</li>\n<li><p><a href=\"https://stackoverflow.com/q/3844931/\">Comparing against a list of the first element repeated</a></p>\n<pre><code>def all_equal_6502(lst):\n    return not lst or [lst[0]]*len(lst) == lst\n</code></pre>\n</li>\n</ol>\n<p>But they have some downsides, namely:</p>\n<ol>\n<li><code>all_equal</code> and <code>all_equal2</code> can use any iterators, but the others must take a sequence input, typically concrete containers like a list or tuple.</li>\n<li><code>all_equal</code> and <code>all_equal3</code> stop as soon as a difference is found (what is called &quot;<a href=\"https://en.wikipedia.org/wiki/Short-circuit_evaluation\" rel=\"noreferrer\">short circuit</a>&quot;), whereas all the alternatives require iterating over the entire list, even if you can tell that the answer is <code>False</code> just by looking at the first two elements.</li>\n<li>In <code>all_equal2</code> the content must be <a href=\"https://docs.python.org/3/glossary.html#term-hashable\" rel=\"noreferrer\">hashable</a>. A list of lists will raise a <code>TypeError</code> for example.</li>\n<li><code>all_equal2</code> (in the worst case) and <code>all_equal_6502</code> create a copy of the list, meaning you need to use double the memory.</li>\n</ol>\n<p>On Python 3.9, using <a href=\"https://github.com/nschloe/perfplot\" rel=\"noreferrer\"><code>perfplot</code></a>, we get these timings (lower <code>Runtime [s]</code> is better):</p>\n<p><a href=\"https://i.stack.imgur.com/P44QA.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/P44QA.png\" alt=\"for a list with a difference in the first two elements, groupby is fastest\" /></a><a href=\"https://i.stack.imgur.com/jLwdT.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/jLwdT.png\" alt=\"for a list with no differences, count(l[0]) is fastest\" /></a></p>\n\n", "questionSource": "https://stackoverflow.com/questions/3844801/check-if-all-elements-in-a-list-are-identical"}