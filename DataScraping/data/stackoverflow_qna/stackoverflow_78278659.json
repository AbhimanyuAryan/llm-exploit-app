{"questionTitle": "Is mypy contradicting itself or is it just me? Mypy is giving an error on a variable but not on the exact same literal", "question": "<p>The following code:</p>\n<pre><code>def foo(bar: dict[int | float, int | float]) -&gt; None:\n    pass\n\nfoo({1: 1})\nbas = {1: 1}\nfoo(bas)\n</code></pre>\n<p>Triggers the following mypy error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>6: error: Argument 1 to &quot;foo&quot; has incompatible type &quot;dict[int, int]&quot;; expected &quot;dict[int | float, int | float]&quot;  [arg-type] \n</code></pre>\n<p>I ran in to this error using pyarrow, in the function <code>Table.replace_schema_metadata</code>.</p>\n<ol>\n<li><p>The error is in line 6 not in line 4: i.e. using a literal is OK,\nbut not the same value as a variable. Why?</p>\n</li>\n<li><p>Why is <code>dict[int, int]</code> not compatible with <code>dict[int | float, int | float]</code>?</p>\n</li>\n<li><p>What can I do to get around this error (apart from <code># type: ignore[arg-type]</code>)?</p>\n</li>\n</ol>\n<p>Using Python 3.11.3 and mypy 1.9.0.</p>\n", "acceptedAnswer": "<p>The important thing here to understand is how MyPy does <em>type inference</em>. Since you don't specify variable types other than function signature, MyPy has to &quot;guess&quot; what are the types for other variables. This exact case is even described in <a href=\"https://mypy.readthedocs.io/en/stable/type_inference_and_annotations.html#context-in-type-inference\" rel=\"nofollow noreferrer\">MyPy docs</a></p>\n<blockquote>\n<p>Declared argument types are also used for type context. In this program mypy knows that the empty list <code>[]</code> should have type <code>list[int]</code> based on the declared type of <code>arg</code> in <code>foo</code>:</p>\n</blockquote>\n<pre><code>def foo(arg: list[int]) -&gt; None:\n    print('Items:', ''.join(str(a) for a in arg))\n\nfoo([])  # OK\n</code></pre>\n<p>And the most relevant part:</p>\n<blockquote>\n<p>However, <strong>context only works within a single statement</strong>. Here mypy requires an annotation for the empty list, since the context would only be available in the following statement:</p>\n</blockquote>\n<pre><code>def foo(arg: list[int]) -&gt; None:\n    print('Items:', ', '.join(arg))\n\na = []  # Error: Need type annotation for &quot;a&quot;\nfoo(a)\n</code></pre>\n<p>And the solution for it - adding a type annotation for the variable:</p>\n<pre><code>a: list[int] = []  # OK\nfoo(a)\n</code></pre>\n<p>Or, in your case:</p>\n<pre><code>bas: dict[int|float, int|float] = {1: 1}\n</code></pre>\n<p>If you want to avoid using lengthy type each time, you can create an alias:</p>\n<pre><code>type numberDict = dict[int|float, int|float]\n\ndef foo(bar: numberDict) -&gt; None:\n    pass\n\nfoo({1: 1})\nbas: numberDict = {1: 1}\nfoo(bas)\n</code></pre>\n<p>As for why dict[int, int] is not compatible with dict[int | float, int | float] - because dicts are mutable, it would be perfectly valid for the function to modify it, inserting a float somewhere, which breaks typing of variable that is supposed to be <code>dict[int, int]</code>. It's better described in <a href=\"https://stackoverflow.com/questions/73603289/why-doesnt-parameter-type-dictstr-unionstr-int-accept-value-of-type-di\">this question</a> (found by mkrieger1).</p>\n", "questionSource": "https://stackoverflow.com/questions/78278659/is-mypy-contradicting-itself-or-is-it-just-me-mypy-is-giving-an-error-on-a-vari"}