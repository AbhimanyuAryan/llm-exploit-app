{"questionTitle": "Alternative syntax/logic to avoid TS &quot;Variable is used before being assigned.&quot;", "question": "<p>I'm trying to write a generator function that would successively return pairs of previous and current values in an iterable.</p>\n<pre><code>function* prevCurrent&lt;T&gt;(iterable: Iterable&lt;T&gt;) {\n    let head = true\n    let previous: T\n    for (const current of iterable) {\n        if (head) {\n            previous = current\n            head = false\n            continue\n        }\n        yield [previous, current]\n        previous = current\n    }\n}\n</code></pre>\n<p>and used as follows:</p>\n<pre><code>const arr = [1, 2, 3]\nfor (const pair of prevCurrent(arr)) {\n    console.log(pair)\n}\n// [1, 2]\n// [2, 3]\n</code></pre>\n<p>However, on the <code>yield</code> line, TypeScript reports:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Variable 'previous' is used before being assigned.\n</code></pre>\n<p>Apparently the static analysis doesn't recognize that the <code>yield</code> can only be reached in the second iteration of the <code>for-of</code>, with <code>previous</code> already set.</p>\n<p>I can easily get around this with the <code>!</code> operator. But <strong>is there an alternative syntax or logic I could use that static analysis would accept?</strong></p>\n", "acceptedAnswer": "<p>The compiler doesn't understand that there's any relationship between <code>head</code> and <code>previous</code>. You could package them both in a single variable like <code>prevHead</code> of a <a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions\" rel=\"nofollow noreferrer\">discriminated union type</a> like <code>{head: true} | {head: false, previous: T}</code>. But once you do that you can collapse it to just <code>undefined | { previous: T }</code>. Indeed if you knew that <code>T</code> could not accept <code>undefined</code> then you'd just collapse it all the way to <code>undefined | T</code>... meaning that you'd use <code>previous</code> alone and not <code>head</code> at all.</p>\n<p>But assuming that <code>undefined extends T</code> is possible, then we can use something equivalent to <code>undefined | { previous: T }</code> to distinguish between the first run through the loop and a run after an <code>undefined</code> value.  Let's do that and rename the variable/property:</p>\n<pre><code>function* prevCurrent&lt;T&gt;(iterable: Iterable&lt;T&gt;) {\n  let previous: { val: T } | undefined;\n  for (const current of iterable) {\n    if (!previous) {\n      previous = { val: current }\n      continue\n    }\n    yield [previous.val, current]\n    previous.val = current\n  }\n}\n</code></pre>\n<p>Here the variable is just <code>previous</code> and it's either <code>undefined</code> or is an object with a <code>val</code> property of type <code>T</code>. That compiles because now there's no way to even represent an invalid state.</p>\n<p><a href=\"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mAVAAgA4CcCmA3AwidLMKAHgBUA+AChik3QEMAjAG0wC5kBJOx1zchQCUyAN4AoZMjZQ0WbPBABnTqOTYGLTmWQBfZAB9k4ACaZgMMJhMBuScmBx0yKhARLZEAkVlxgyWnpmNhEJKSkYfyoAQgwcRSVQ+3C5eLhlZABeMXVNTi9CTGI9ZPC3YksQTFLdUoBPGEwWE2QAbTiFdKUAOg0WABpkAp8AXVKOhN7NLKHvIqh7Wt0gA\" rel=\"nofollow noreferrer\">Playground link to code</a></p>\n", "questionSource": "https://stackoverflow.com/questions/78273650/alternative-syntax-logic-to-avoid-ts-variable-is-used-before-being-assigned"}