{"questionTitle": "matrix initialisation using pointers", "question": "<pre><code>int (*mat)[3]={{1,7,8},{1,2,3},{334,43,8}};\n</code></pre>\n<p>Gives errors like:</p>\n<pre><code>warning: braces around scalar initializer\nwarning: initialization of 'int *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\nwarning: excess elements in scalar initializer\n</code></pre>\n<p>But we can initialize arrays as <code>int (*mat)[3]</code>, so why is that allocation a problem?</p>\n<p>I tried to create a 2d array and give elements to it</p>\n", "acceptedAnswer": "<p>The simplest solution would be to simply use a two-dimensional array:</p>\n<pre><code>    int m[][3] = {{1,7,8}, {1,2,3}, {334,43,8}};\n</code></pre>\n<p>However, pursuing the idea of having an array of pointers, the problem in the OP is that e.g. <code>{1,7,8}</code> is not a valid initializer for an <code>int *</code>. To initialize a pointer to an array directly, a compound literal can be used:</p>\n<pre><code>    int *m[] = {(int []){1,7,8}, (int []){1,2,3}, (int []){334,43,8}};\n</code></pre>\n<p>This will create an array of pointers to the temporary objects specified by the compound literals. The lifetime of these temporary objects is the block of code where they are defined, i.e. the same as <code>m</code>.</p>\n<p>While this is unusual, it offers the flexibility over the 2-dimensional array that not all rows need to have the same size. This comes at the cost of increased storage size (since row pointers are stored explicitly) and increased access time, so it cannot be recommended to use this approach for a common matrix.</p>\n", "questionSource": "https://stackoverflow.com/questions/78278269/matrix-initialisation-using-pointers"}