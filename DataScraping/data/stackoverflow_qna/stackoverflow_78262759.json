{"questionTitle": "How can I access arguments of a call to a function stored in a custom environment?", "question": "<p>I am in the following situation:</p>\n<ul>\n<li>I use a custom environment (<code>some_env</code>) that stores a list of functions (such as <code>some_function()</code>). Note that I don\u2019t own this environment, it is imported from another package</li>\n<li>I have a user-facing function that calls the function stored in the environment under the hood.</li>\n</ul>\n<pre class=\"lang-r prettyprint-override\"><code>library(rlang)\n\n# Define a custom environment where I store a function.\n# This is done in another package.\nsome_env &lt;- new.env(parent = emptyenv())\nclass(some_env) &lt;- &quot;custom_class&quot;\nsome_env$some_function &lt;- function(x) {\n  print(x)\n}\n\n# Make a user-facing function that calls the function stored in the custom\n# environment under the hood\nuser_facing_fn &lt;- function(val = 1) {\n  some_env$some_function(val)\n}\n\nuser_facing_fn()\n#&gt; [1] 1\n</code></pre>\n<p>My objective is to capture the call to this internal function (<code>some_function()</code>). I could do this inside <code>user_facing_fn()</code> using <code>rlang::expr()</code> and <code>!!</code>. However, in the real situation, I have many user-facing functions so using this combination would greatly clutter the code.</p>\n<p>Therefore, I thought about defining a custom class and <code>$</code> call so that I can access the call before dispatching it to the next method.</p>\n<pre class=\"lang-r prettyprint-override\"><code># Define a custom `$` to access the call before evaluating it \n`$.custom_class` &lt;- function(x, name) {\n  fc &lt;- rlang::frame_call()\n  \n  ### For debugging\n  cat(&quot;----------------\\n&quot;)\n  print(fc)\n  cat(&quot;----------------\\n&quot;)\n  print(str(fc))\n  cat(&quot;----------------\\n&quot;)\n  print(deparse(fc))\n  ###\n  \n  NextMethod(&quot;$&quot;)  # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Not interested in this part\n}\n</code></pre>\n<p>It seems that I can capture the call with <code>frame_call()</code> and it is correctly printed (see the first printed line below):</p>\n<pre class=\"lang-r prettyprint-override\"><code>user_facing_fn()\n#&gt; ----------------\n#&gt; some_env$some_function(val)\n#&gt; ----------------\n#&gt;  language `$.custom_class`(some_env, &quot;some_function&quot;)\n#&gt;  - attr(*, &quot;srcref&quot;)= 'srcref' int [1:8] 14 3 14 29 3 29 14 14\n#&gt;   ..- attr(*, &quot;srcfile&quot;)=Classes 'srcfilecopy', 'srcfile' &lt;environment: 0x000001d40b90c0c0&gt; \n#&gt; NULL\n#&gt; ----------------\n#&gt; [1] &quot;`$.custom_class`(some_env, \\&quot;some_function\\&quot;)&quot;\n#&gt; [1] 1\n</code></pre>\n<p>However, I can\u2019t find a way to access the value of <code>val</code> after storing the expression in <code>fc</code>. As you can see, it is deparsed as <code>`$.custom_class`(some_env, &quot;some_function&quot;)</code> but I cannot access <code>val</code>. I tried many <code>rlang</code> functions but couldn\u2019t find something that works.</p>\n<p>To clarify, what I want is to be able to access the value of <code>val</code> (in the example above, it would be <code>1</code>) when I\u2019m inside <code>$.custom_class</code>. Is this possible? I\u2019m fine with using either base R or <code>rlang</code>.</p>\n<hr />\n<p><strong>Edit following MrFlick's comment:</strong></p>\n<p>My objective is that <code>user_facing_fn()</code> returns the output and an attribute containing the call to the internal function, like this:</p>\n<pre class=\"lang-r prettyprint-override\"><code>...\n\n# Make a user-facing function that calls the function stored in the custom\n# environment under the hood\nuser_facing_fn &lt;- function(val = 1) {\n  my_expr &lt;- expr(some_env$some_function(!!val))\n  out &lt;- eval_bare(my_expr)\n  attr(out, &quot;original_query&quot;) &lt;- my_expr\n  out\n}\n\nuser_facing_fn(3)\n#&gt; [1] 3\n#&gt; attr(,&quot;original_query&quot;)\n#&gt; some_env$some_function(3)\n</code></pre>\n<p>The problem is that I have many user-facing functions, and in some of them I want to capture several calls to functions stored in <code>some_env</code>. Therefore, I thought that instead of duplicating this <code>expr()</code> + <code>!!</code>, I could automatically capture the call in <code>$</code> and I wouldn't need to modify the user-facing functions (or just slightly).</p>\n", "acceptedAnswer": "<p>I think I found a way thanks to the various comments.</p>\n<h2>Setup</h2>\n<p>I\u2019m just putting back my setting here:</p>\n<pre class=\"lang-r prettyprint-override\"><code>library(rlang)\n\n# Define a custom environment where I store a function.\n# This is done in another package.\nsome_env &lt;- new.env(parent = emptyenv())\nclass(some_env) &lt;- &quot;custom_class&quot;\nsome_env$some_function &lt;- function(x) {\n  x\n}\n\n# Make a user-facing function that calls the function stored in the custom\n# environment under the hood\nuser_facing_fn &lt;- function(val = 1) {\n  some_env$some_function(val)\n}\n\nuser_facing_fn(1)\n#&gt; [1] 1\n</code></pre>\n<h2>Modify the environment</h2>\n<p>I can modify the functions in <code>some_env</code> so that I can obtain the call and store it somewhere (e.g in an attribute) before evaluating it. First I need <code>eapply()</code> to go through all the functions stored in <code>some_env</code> (in this example, there\u2019s only <code>some_function()</code>):</p>\n<pre class=\"lang-r prettyprint-override\"><code>modify_env &lt;- function(env) {\n  \n  # Here I overwrite all functions defined in `some_env`. In this example,\n  # there's only one.\n  \n  eapply(env, function(fun) {\n    function(...) {\n      # Evaluate the args that are passed to the `some_function()`, which is\n      # only &quot;val&quot; in this example.\n      # First we capture unevaluated args, then we evaluate each of them in the\n      # caller env.\n      \n      fc &lt;- as.list(frame_call())\n      # The first element is the call, which is `some_env$some_function()` here.\n      # It is not an argument so I remove it.\n      fc1 &lt;- fc[[1]]\n      fc[[1]] &lt;- NULL\n      fc &lt;- lapply(fc, eval_bare, env = caller_env())\n      \n      # Evaluate the call. This produces the output (which is equal to the \n      # input in this example).\n      out &lt;- call2(fun, !!!fc) |&gt; eval_bare()\n      \n      # Build the call that will be stored in the attributes of the output.\n      args &lt;- list2(...)\n      full_call &lt;- call2(fc1, !!!fc)\n      full_call &lt;- deparse(full_call)\n      \n      # Store the call in the attribute of the output.\n      attr(out, &quot;original_expr&quot;) &lt;- full_call\n      out\n    }\n  })\n}\n</code></pre>\n<p>Now I define my own environment by cloning <code>some_env</code> and then modify it:</p>\n<pre class=\"lang-r prettyprint-override\"><code>my_new_env &lt;- modify_env(\n  env_clone(some_env)\n)\n</code></pre>\n<p>Finally, I define a custom <code>$</code> to access the call to <code>some_env$some_function()</code> before evaluating it. Here, instead of returning <code>some_env$some_function</code>, which would only return the input without storing the call, I return the modified function from the custom environment:</p>\n<pre class=\"lang-r prettyprint-override\"><code>`$.custom_class` &lt;- function(x, name) {\n  my_new_env[[name]]\n}\n</code></pre>\n<p>We now have the original call stored in the output\u2019s attributes:</p>\n<pre class=\"lang-r prettyprint-override\"><code>user_facing_fn()\n#&gt; [1] 1\n#&gt; attr(,&quot;original_expr&quot;)\n#&gt; [1] &quot;some_env$some_function(1)&quot;\n\n\nuser_facing_fn(3)\n#&gt; [1] 3\n#&gt; attr(,&quot;original_expr&quot;)\n#&gt; [1] &quot;some_env$some_function(3)&quot;\n</code></pre>\n", "questionSource": "https://stackoverflow.com/questions/78262759/how-can-i-access-arguments-of-a-call-to-a-function-stored-in-a-custom-environmen"}