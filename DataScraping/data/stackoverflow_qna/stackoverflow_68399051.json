{"questionTitle": "Python convert dictionary to argparse", "question": "<p>Right now, I have a script that can accept command line arguments using argparse. For example, like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>#foo.py\ndef function_with_args(optional_args=None):\n  parser = argparse.ArgumentParser()\n  # add some arguments\n  args = parser.parse_args(optional_args)\n  # do something with args\n</code></pre>\n<p>However, I'd like to be able to use this function with a dictionary instead, for example with something like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def function_using_dict(**kwargs):\n  # define parser and add some arguments\n  args = parser.parse_dict_args(kwargs)\n  # everything else is the same\n</code></pre>\n<p>Note that I have a lot of arguments with default values in argparse which I'd like to use, so the following wouldn't work:</p>\n<pre><code>def function_no_default_args(**kwargs):\n  args = kwargs # not using default values that we add to the parser!\n</code></pre>\n", "acceptedAnswer": "<p><code>argparse.Namespace</code> is a relatively simple object subclass, with most of its code devoted to displaying the attributes (as <code>print(args)</code> shows).  Internally <code>parse_args</code> uses <code>get_attr</code> and <code>set_attr</code> to access the namespace, minimizing the assumptions about attributes names.</p>\n<p>When using subparsers, the subparser starts with a 'blank' namespace, and uses the following code to copy its values to the main namespace.</p>\n<pre><code>    # In case this subparser defines new defaults, we parse them\n    # in a new namespace object and then update the original\n    # namespace for the relevant parts.\n    subnamespace, arg_strings = parser.parse_known_args(arg_strings, None)\n    for key, value in vars(subnamespace).items():\n        setattr(namespace, key, value)\n</code></pre>\n<p>Originally the main namespace was passed to the subparser, eg.  <code>parser.parse_known_args(arg_strings, namespace)</code>, but the current version lets the subparser defaults take priority.</p>\n<p>Handling defaults is a bit complicated.  If you don't have any required arguments then</p>\n<pre><code> args = parser.parse_args([])\n</code></pre>\n<p>will set all the defaults.  Or you could look at the start of <code>parse.parse_known_args</code> to see how defaults are inserted into the namespace at the start of parsing.  Just beware that there's an added step at the end of parsing that runs remaining defaults through their respective <code>type</code> functions.</p>\n", "questionSource": "https://stackoverflow.com/questions/68399051/python-convert-dictionary-to-argparse"}