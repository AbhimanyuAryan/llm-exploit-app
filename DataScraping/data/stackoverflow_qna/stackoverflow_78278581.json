{"questionTitle": "How can I mock the result of a third-party builder so I can test my Java class?", "question": "<p>I have a simple Java Spring Boot application to send push notifications to Android and iOS apps. There is a service class that sends the push notifications using a pusher class. The pusher class is an interface with <code>connect</code>, <code>sendNotification</code> and <code>disconnect</code> methods, there is an Android implementation and an iOS implementation. The service uses the correct instance when sending a notification.</p>\n<p>The <code>connect</code> method creates a connection by building a client using a builder from an external library. The client is then set in a private global variable so it can be used later to send push notifications.</p>\n<p>I want to write unit tests for the service and for both the pusher implementations. However, I don't want to connect with the actual push notification servers of Google and Apple. How can I mock the client created by the builder? I feel that the current design of the classes isn't very testable, how do I improve the testability of my classes?</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Service {\n    public void sendNotification(String notification, DeviceOS deviceOS) {\n        Pusher androidPusher = new AndroidPusher();\n        Pusher iOSPusher = new IOSPusher();\n\n        switch(deviceOS) {\n            case DeviceOS.ANDROID:\n                androidPusher.connect();\n                androidPusher.sendNotification(notification);\n                androidPusher.disconnect();\n                break;\n            case DeviceOS.IOS:\n                IOSPusher.connect();\n                IOSPusher.sendNotification(notification);\n                IOSPusher.disconnect();\n                break;\n        }\n    }\n}\n\npublic class IOSPusher() implements Pusher {\n    private Client client;\n\n    public void connect() {\n        if (client != null) {\n            return; // Already connected\n        }\n        client = ClientBuilder()\n          .setServer(&quot;server.name&quot;)\n          .setCredentials(new File(&quot;/cred&quot;), &quot;password&quot;)\n          .build();\n    }\n\n    public void sendNotification(String notification) {\n        PushNotification pushNotification = new PushNotification(notification);\n        client.sendNotification(pushNotification);\n        // Check the client response and do some bookkeeping based on the response.\n    }\n\n    public void disconnect() {\n        if (client != null) {\n            client.close();\n        }\n    }\n}\n</code></pre>\n", "acceptedAnswer": "<p>There are a few issues with your code:</p>\n<ul>\n<li>You're creating a new <code>AndroidPusher</code> <em>and</em> a new <code>IOSPusher</code> every single time you want to send a notification</li>\n<li>you're always ignoring one of the two instances, which makes it pretty pointless to have both of them at the same time</li>\n<li>both cases execute the exact same code</li>\n<li>what if you need more <code>DeviceOS</code> in the future? Would you add another instance and another piece of code for each device?</li>\n<li>The <code>Pusher</code> instances only exist locally, that means your method is not testable at all</li>\n</ul>\n<p>So, what to do? Both your <code>AndroidPusher</code> and <code>IOSPusher</code> implement the <code>Pusher</code> interface, so use that fact to make your code more generic and remove the tight coupling inside your method.</p>\n<p>I'd suggest doing something like this:</p>\n<pre><code>public void sendNotification(String notification, Pusher pusher) {\n    pusher.connect();\n    pusher.sendNotification(notification);\n    pusher.disconnect();\n}\n</code></pre>\n<p>With this approach you remove the need to know which kind of <code>Pusher</code> implementations you have. You can then determine what implementation you actually need from the outside (based on the <code>DeviceOS</code> enum, for example). Also, you've added a way to make your method testable.</p>\n<p>Afterwards, you can inject a mocked version of a <code>Pusher</code> into your method when testing. For example:</p>\n<pre><code>@Test\npublic void test() {\n    Pusher mockPusher = Mockito.mock(Pusher.class);\n    // add your mocked behavior here\n\n    systemUnderTest.sendNotification(&quot;Test Notification&quot;, mockPusher);\n\n    // add your asserts here\n}\n</code></pre>\n", "questionSource": "https://stackoverflow.com/questions/78278581/how-can-i-mock-the-result-of-a-third-party-builder-so-i-can-test-my-java-class"}