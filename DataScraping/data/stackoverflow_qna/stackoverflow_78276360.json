{"questionTitle": "Sort output in bash based on character count not including spaces, but retain the spaces in output", "question": "<p>Given the following contents of file:</p>\n<pre><code>a b c \nabcde\nab cd ef\nabcdefg\na\na b\n</code></pre>\n<p>I want to rearrange the output based on the number of non-space characters, but retain the spaces when the output is given. Additionally, I need this to be a single command, not something that I put into a script.</p>\n<p>Pretty much everything I try ends up like this:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>cat file.txt |awk '{ count=gsub(/ /,&quot;&quot;); print length($0), $0 }' | sort\n</code></pre>\n<pre><code>1 a\n2 ab\n3 abc\n5 abcde\n6 abcdef\n7 abcdefg\n</code></pre>\n<p>Which does give me the correct count and sort, but it also removes the spaces from the original output, which I do not want. The desired output would be</p>\n<pre><code>1 a \n2 a b\n3 a b c \n5 abcde\n6 ab cd ef\n7 abcdefg\n</code></pre>\n", "acceptedAnswer": "<p>Applying the <a href=\"https://rosettacode.org/wiki/Decorate-sort-undecorate_idiom\" rel=\"nofollow noreferrer\">Decorate-Sort-Undecorate idiom</a> with any awk:</p>\n<pre><code>$ awk -v OFS='\\t' '{print length() - gsub(/[[:space:]]/,&quot;&amp;&quot;), NR, $0}' file |\n    sort -n -k1,1 -k2,2 | cut -f3-\na\na b\na b c\nabcde\nab cd ef\nabcdefg\n</code></pre>\n<p>The above is doing:</p>\n<ul>\n<li><strong>Decorate</strong> with <code>awk</code>: The awk command is decorating the input file by adding the number of non-blank chars and then the input line number before the original input line. I'm separating the <code>awk</code> output fields with tabs as that's a default separator value for both of the subsequent commands in the pipeline, <code>sort</code> and <code>cut</code>.</li>\n<li><strong>Sort</strong> with <code>sort</code> - I'm sorting using the number of non-spaces first and then the original line number second so that if 2 lines have the same number of characters they retain their input order in the output</li>\n<li><strong>Undecorate</strong> with <code>cut</code> - I'm just printing from the 3rd tab-separated field on, which takes us back to the original input line.</li>\n</ul>\n<p>To see how that works, just add the commands one at a time:</p>\n<pre><code>$ cat file\na b c\nabcde\nab cd ef\nabcdefg\na\na b\n</code></pre>\n<p>\n<pre><code>$ awk -v OFS='\\t' '{print length() - gsub(/[[:space:]]/,&quot;&amp;&quot;), NR, $0}' file\n3       1       a b c\n5       2       abcde\n6       3       ab cd ef\n7       4       abcdefg\n1       5       a\n2       6       a b\n</code></pre>\n<p>\n<pre><code>$ awk -v OFS='\\t' '{print length() - gsub(/[[:space:]]/,&quot;&amp;&quot;), NR, $0}' file | sort -n -k1,1 -k2,2\n1       5       a\n2       6       a b\n3       1       a b c\n5       2       abcde\n6       3       ab cd ef\n7       4       abcdefg\n</code></pre>\n<p>\n<pre><code>$ awk -v OFS='\\t' '{print length() - gsub(/[[:space:]]/,&quot;&amp;&quot;), NR, $0}' file | sort -n -k1,1 -k2,2 | cut -f3-\na\na b\na b c\nabcde\nab cd ef\nabcdefg\n</code></pre>\n", "questionSource": "https://stackoverflow.com/questions/78276360/sort-output-in-bash-based-on-character-count-not-including-spaces-but-retain-th"}