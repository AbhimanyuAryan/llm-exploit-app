{"questionTitle": "How do I use valgrind to find memory leaks?", "question": "<p>How do I use valgrind to find the memory leaks in a program?</p>\n<p>I am using Ubuntu 10.04 and I have a program <code>a.c</code>.</p>\n", "acceptedAnswer": "<h1>How to Run Valgrind</h1>\n<p>First of all check you have Valgrind installed, if not:</p>\n<pre><code>sudo apt install valgrind  # Ubuntu, Debian, etc.\nsudo yum install valgrind  # RHEL, CentOS, Fedora, etc.\nsudo pacman -Syu valgrind  # Arch, Manjaro, Garuda, etc.\nsudo pkg ins valgrind      # FreeBSD\n</code></pre>\n<p>Valgrind is readily usable for C/C++ code, but can even be used for other\nlanguages when configured properly (see <a href=\"https://stackoverflow.com/questions/20112989/how-to-use-valgrind-with-python\">this</a> for Python).</p>\n<p><strong>To run Valgrind</strong>, pass the executable as an argument (along with any\nparameters to the program).</p>\n<pre><code>valgrind --leak-check=full \\\n         --show-leak-kinds=all \\\n         --track-origins=yes \\\n         --verbose \\\n         --log-file=valgrind-out.txt \\\n         ./executable exampleParam1\n</code></pre>\n<p>The flags are, in short:</p>\n<ul>\n<li><code>--leak-check=full</code>: &quot;each individual leak will be shown in detail&quot;</li>\n<li><code>--show-leak-kinds=all</code>: Show all of &quot;definite, indirect, possible, reachable&quot; leak kinds in the &quot;full&quot; report.</li>\n<li><code>--track-origins=yes</code>: Favor useful output over speed. This tracks the origins of uninitialized values, which could be very useful for memory errors. Consider turning off if Valgrind is unacceptably slow.</li>\n<li><code>--verbose</code>: Can tell you about unusual behavior of your program. Repeat for more verbosity.</li>\n<li><code>--log-file</code>: Write to a file. Useful when output exceeds terminal space.</li>\n</ul>\n<p>Finally, you would like to see a Valgrind report that looks like this:</p>\n<pre><code>HEAP SUMMARY:\n    in use at exit: 0 bytes in 0 blocks\n  total heap usage: 636 allocs, 636 frees, 25,393 bytes allocated\n \nAll heap blocks were freed -- no leaks are possible\n \nERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\nERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n</code></pre>\n<hr />\n<h1>I have a leak, but <em>WHERE</em>?</h1>\n<p>So, you have a memory leak, and Valgrind isn't saying anything meaningful.\nPerhaps, something like this:</p>\n<pre><code>5 bytes in 1 blocks are definitely lost in loss record 1 of 1\n   at 0x4C29BE3: malloc (vg_replace_malloc.c:299)\n   by 0x40053E: main (in /home/Peri461/Documents/executable)\n</code></pre>\n<p>Let's take a look at the C code I wrote too:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n\nint main() {\n    char* string = malloc(5 * sizeof(char)); //LEAK: not freed!\n    return 0;\n}\n</code></pre>\n<p>Well, there were 5 bytes lost. How did it happen? The error report just says\n<code>main</code> and <code>malloc</code>. In a larger program, that would be seriously troublesome to\nhunt down. <strong>This is because of how the executable was compiled</strong>. We can\nactually get line-by-line details on what went wrong. Recompile your program\nwith a debug flag (I'm using <code>gcc</code> here):</p>\n<pre><code>gcc -o executable -std=c11 -Wall main.c         # suppose it was this at first\ngcc -o executable -std=c11 -Wall -ggdb3 main.c  # add -ggdb3 to it\n</code></pre>\n<p>Now with this debug build, <strong>Valgrind points to the exact line of code</strong>\nallocating the memory that got leaked! (The wording is important: it might not\nbe exactly where your leak is, but <em>what</em> got leaked. The trace helps you find\n<em>where</em>.)</p>\n<pre><code>5 bytes in 1 blocks are definitely lost in loss record 1 of 1\n   at 0x4C29BE3: malloc (vg_replace_malloc.c:299)\n   by 0x40053E: main (main.c:4)\n</code></pre>\n<p><code>-ggdb3</code> includes detailed debug annotations in the binary that Valgrind can use to give you more precise information. Compiled this way, GCC will still use the default optimization level (<code>-O2</code>), which will transform your code to improve its efficiency. Sometimes that might optimize away passages in your code you want to explore closely, or have other surprising results. In those cases, you might want to try the flag <code>-Og</code> instead, which will include detailed debug annotations <em>and</em> use only restrained, debugging-friendly optimizations so that the compiled binary will more closely match what you wrote. You can do that like this:</p>\n<pre><code>gcc -o executable -std=c11 -Wall -Og main.c  # add -Og\n</code></pre>\n<p>You can read about these and other debugging options in <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html\" rel=\"nofollow noreferrer\">3.10 Options for Debugging Your Program</a> in the GCC docs. For detailed information on how <code>-Og</code> affects optimization, see <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html\" rel=\"nofollow noreferrer\">3.11 Options That Control Optimization</a>.</p>\n<hr />\n<h1>Techniques for Debugging Memory Leaks &amp; Errors</h1>\n<ul>\n<li><p>Make use of <a href=\"https://en.cppreference.com/w/\" rel=\"nofollow noreferrer\">cppreference</a>! It has great documentation on C and C++ functions. Also consider <a href=\"http://www.cplusplus.com/\" rel=\"nofollow noreferrer\">www.cplusplus.com</a>.</p>\n</li>\n<li><p>General advice for memory leaks:</p>\n</li>\n<li><p>If you can, use RAII and most of your problems will just go away.</p>\n</li>\n<li><p>Make sure your dynamically allocated memory does in fact get freed.</p>\n</li>\n<li><p>Don't allocate memory and forget to assign the pointer.</p>\n</li>\n<li><p>Don't overwrite a pointer with a new one unless the old memory is freed.</p>\n</li>\n<li><p>General advice for memory errors:</p>\n</li>\n<li><p>Access and write to addresses and indices you're sure belong to you. Memory\nerrors are different from leaks; they're often just <code>IndexOutOfBoundsException</code>\ntype problems.</p>\n</li>\n<li><p>Don't access or write to memory after freeing it.</p>\n</li>\n<li><p>Sometimes your leaks/errors can be linked to one another, much like an IDE discovering that you haven't typed a closing bracket yet. Resolving one issue can resolve others, so look for one that looks a good culprit and apply some of these ideas:</p>\n</li>\n<li><p>List out the functions in your code that depend on/are dependent on the\n&quot;offending&quot; code that has the memory error. Follow the program's execution\n(maybe even in <code>gdb</code> perhaps), and look for precondition/postcondition errors. The idea is to trace your program's execution while focusing on the lifetime of allocated memory.</p>\n</li>\n<li><p>Try commenting out the &quot;offending&quot; block of code (within reason, so your code\nstill compiles). If the Valgrind error goes away, you've found where it is.</p>\n</li>\n<li><p>If all else fails, try looking it up. Valgrind has <a href=\"http://valgrind.org/docs/manual/manual.html\" rel=\"nofollow noreferrer\">documentation</a> too!</p>\n</li>\n</ul>\n<hr />\n<h1>A Look at Common Leaks and Errors</h1>\n<h3>Watch your pointers</h3>\n<pre><code>60 bytes in 1 blocks are definitely lost in loss record 1 of 1\n   at 0x4C2BB78: realloc (vg_replace_malloc.c:785)\n   by 0x4005E4: resizeArray (main.c:12)\n   by 0x40062E: main (main.c:19)\n</code></pre>\n<p>And the code:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\nstruct _List {\n    int32_t* data;\n    int32_t length;\n};\ntypedef struct _List List;\n\nList* resizeArray(List* array) {\n    int32_t* dPtr = array-&gt;data;\n    dPtr = realloc(dPtr, 15 * sizeof(int32_t)); //doesn't update array-&gt;data\n    return array;\n}\n\nint main() {\n    List* array = calloc(1, sizeof(List));\n    array-&gt;data = calloc(10, sizeof(int32_t));\n    array = resizeArray(array);\n\n    free(array-&gt;data);\n    free(array);\n    return 0;\n}\n</code></pre>\n<p>As a teaching assistant, I've seen this mistake often. The student makes use of\na local variable and forgets to update the original pointer. The error here is\nnoticing that <code>realloc</code> can actually move the allocated memory somewhere else\nand change the pointer's location. We then leave <code>resizeArray</code> without telling\n<code>array-&gt;data</code> where the array was moved to.</p>\n<h3>Invalid write</h3>\n<pre><code>1 errors in context 1 of 1:\nInvalid write of size 1\n   at 0x4005CA: main (main.c:10)\n Address 0x51f905a is 0 bytes after a block of size 26 alloc'd\n   at 0x4C2B975: calloc (vg_replace_malloc.c:711)\n   by 0x400593: main (main.c:5)\n</code></pre>\n<p>And the code:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\nint main() {\n    char* alphabet = calloc(26, sizeof(char));\n\n    for(uint8_t i = 0; i &lt; 26; i++) {\n        *(alphabet + i) = 'A' + i;\n    }\n    *(alphabet + 26) = '\\0'; //null-terminate the string?\n\n    free(alphabet);\n    return 0;\n}\n</code></pre>\n<p>Notice that Valgrind points us to the commented line of code above. The array\nof size 26 is indexed [0,25] which is why <code>*(alphabet + 26)</code> is an invalid\nwrite\u2014it's out of bounds. An invalid write is a common result of\noff-by-one errors. Look at the left side of your assignment operation.</p>\n<h3>Invalid read</h3>\n<pre><code>1 errors in context 1 of 1:\nInvalid read of size 1\n   at 0x400602: main (main.c:9)\n Address 0x51f90ba is 0 bytes after a block of size 26 alloc'd\n   at 0x4C29BE3: malloc (vg_replace_malloc.c:299)\n   by 0x4005E1: main (main.c:6)\n</code></pre>\n<p>And the code:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\nint main() {\n    char* destination = calloc(27, sizeof(char));\n    char* source = malloc(26 * sizeof(char));\n\n    for(uint8_t i = 0; i &lt; 27; i++) {\n        *(destination + i) = *(source + i); //Look at the last iteration.\n    }\n\n    free(destination);\n    free(source);\n    return 0;\n}\n</code></pre>\n<p>Valgrind points us to the commented line above. Look at the last iteration here,\nwhich is <br> <code>*(destination + 26) = *(source + 26);</code>. However, <code>*(source + 26)</code> is\nout of bounds again, similarly to the invalid write. Invalid reads are also a\ncommon result of off-by-one errors. Look at the right side of your assignment\noperation.</p>\n<hr />\n<h1>The Open Source (U/Dys)topia</h1>\n<p>How do I know when the leak is mine? How do I find my leak when I'm using\nsomeone else's code? I found a leak that isn't mine; should I do something? All\nare legitimate questions. First, 2 real-world examples that show 2 classes of\ncommon encounters.</p>\n<h3><a href=\"http://www.digip.org/jansson/\" rel=\"nofollow noreferrer\">Jansson</a>: a JSON library</h3>\n<pre><code>#include &lt;jansson.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char* string = &quot;{ \\&quot;key\\&quot;: \\&quot;value\\&quot; }&quot;;\n\n    json_error_t error;\n    json_t* root = json_loads(string, 0, &amp;error); //obtaining a pointer\n    json_t* value = json_object_get(root, &quot;key&quot;); //obtaining a pointer\n    printf(&quot;\\&quot;%s\\&quot; is the value field.\\n&quot;, json_string_value(value)); //use value\n\n    json_decref(value); //Do I free this pointer?\n    json_decref(root);  //What about this one? Does the order matter?\n    return 0;\n}\n</code></pre>\n<p>This is a simple program: it reads a JSON string and parses it. In the making,\nwe use library calls to do the parsing for us. Jansson makes the necessary\nallocations dynamically since JSON can contain nested structures of itself.\nHowever, this doesn't mean we <code>decref</code> or &quot;free&quot; the memory given to us from\nevery function. In fact, this code I wrote above throws both an &quot;Invalid read&quot;\nand an &quot;Invalid write&quot;. Those errors go away when you take out the <code>decref</code> line\nfor <code>value</code>.</p>\n<p>Why? The variable <code>value</code> is considered a &quot;borrowed reference&quot; in the Jansson\nAPI. Jansson keeps track of its memory for you, and you simply have to <code>decref</code>\nJSON structures independent of each other. The lesson here:\n<strong>read the documentation</strong>. Really. It's sometimes hard to understand, but\nthey're telling you why these things happen. Instead, we have\n<a href=\"https://stackoverflow.com/questions/45410841/json-decref-cause-memory-invalid-write\">existing questions</a> about this memory error.</p>\n<h3><a href=\"https://www.libsdl.org/\" rel=\"nofollow noreferrer\">SDL</a>: a graphics and gaming library</h3>\n<pre><code>#include &quot;SDL2/SDL.h&quot;\n\nint main(int argc, char* argv[]) {\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO) != 0) {\n        SDL_Log(&quot;Unable to initialize SDL: %s&quot;, SDL_GetError());\n        return 1;\n    }\n\n    SDL_Quit();\n    return 0;\n}\n</code></pre>\n<p>What's wrong with <a href=\"http://wiki.libsdl.org/SDL_Init?highlight=%28%5CbCategoryAPI%5Cb%29%7C%28SDLFunctionTemplate%29\" rel=\"nofollow noreferrer\">this code</a>? It consistently leaks ~212 KiB of memory for me. Take a moment to think about it. We turn SDL on and then off. Answer? There is nothing wrong.</p>\n<p><a href=\"https://stackoverflow.com/questions/1997171/why-does-valgrind-say-basic-sdl-program-is-leaking-memory\">That might sound bizarre at first</a>. Truth be told, graphics are messy and sometimes you have to accept some leaks as being part of the standard library. The lesson here: <strong>you need not quell every memory leak</strong>. Sometimes you just need to <a href=\"https://wiki.wxwidgets.org/Valgrind_Suppression_File_Howto\" rel=\"nofollow noreferrer\">suppress the leaks</a> <em>because they're known issues you can't do anything about</em>. (This is not my permission to ignore your own leaks!)</p>\n<h3>Answers unto the void</h3>\n<p>How do I know when the leak is mine? <br>\nIt is. (99% sure, anyway)</p>\n<p>How do I find my leak when I'm using someone else's code? <br>\nChances are someone else already found it. Try Google! If that fails, use the skills I gave you above. If that fails and you mostly see API calls and little of your own stack trace, see the next question.</p>\n<p>I found a leak that isn't mine; should I do something? <br>\nYes! Most APIs have ways to report bugs and issues. Use them! Help give back to the tools you're using in your project!</p>\n<hr />\n<h1>Further Reading</h1>\n<p>Thanks for staying with me this long. I hope you've learned something, as I tried to tend to the broad spectrum of people arriving at this answer. Some things I hope you've asked along the way: How does C's memory allocator work? What actually is a memory leak and a memory error? How are they different from segfaults? How does Valgrind work? If you had any of these, please do feed your curiousity:</p>\n<ul>\n<li><a href=\"https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/\" rel=\"nofollow noreferrer\">More about <code>malloc</code>, C's memory allocator</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Segmentation_fault\" rel=\"nofollow noreferrer\">Definition of a segmentation fault</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Memory_leak\" rel=\"nofollow noreferrer\">Definition of a memory leak</a></li>\n<li><a href=\"http://valgrind.org/docs/manual/mc-manual.html#mc-manual.overview\" rel=\"nofollow noreferrer\">Definition of a memory access error</a></li>\n<li><a href=\"https://stackoverflow.com/a/1656236/7851115\">How does Valgrind work?</a></li>\n</ul>\n", "questionSource": "https://stackoverflow.com/questions/5134891/how-do-i-use-valgrind-to-find-memory-leaks"}