{"questionTitle": "MEF vs. IAsyncDisposable or iterate over all instantiated exports", "question": "<p>I've shared MEF exports that implement <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.iasyncdisposable?view=net-6.0\" rel=\"nofollow noreferrer\"><code>IAsyncDisposable</code></a>.\nIf an export in MEF implements <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-6.0\" rel=\"nofollow noreferrer\"><code>IDisposable</code></a> it will be disposed when the composition container (or maybe the catalog) is disposed.</p>\n<p><code>IAsyncDisposable</code> is not recognized from MEF. Is there any solution to that problem?</p>\n<p>If not:\nIf the application will be shut down I try to iterate over all already created exports that implement <code>IAsyncDisposable</code> but there seems to be no possibility to do that.</p>\n<p>Let's assume that I've a typed method (maybe created via reflection) I'm able to call <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.composition.hosting.exportprovider.getexport?view=dotnet-plat-ext-6.0#system-componentmodel-composition-hosting-exportprovider-getexport-1\" rel=\"nofollow noreferrer\"><code>CompositionContainer.GetExport&lt;T&gt;()</code></a> that returns a <code>Lazy&lt;T&gt;</code>. The problem is that <code>IsValueCreated</code> is <code>false</code> - even if that import has a running shared instance.</p>\n<p>Is there any way to iterate over all exports that have been already instantiated?</p>\n<p>This code shows that the <code>Lazy&lt;T&gt;</code>-instance does not contain the already known exported value:</p>\n<pre><code>public class Program\n{\n    public static void Main()\n    {\n        using var catalog = new AssemblyCatalog(typeof(Program).Assembly);\n        using var container = new CompositionContainer(catalog);\n        \n        var dummyInstance = container.GetExport&lt;Foo&gt;().Value;\n        Console.WriteLine($&quot;HasInstance: {dummyInstance is not null}&quot;);\n        \n        var export = container.GetExport&lt;Foo&gt;();\n        Console.WriteLine($&quot;IsValueCreated: {export.IsValueCreated}&quot;);\n    }\n}\n\n[Export]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class Foo \n{\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>HasInstance: True\nIsValueCreated: False\n</code></pre>\n<p><a href=\"https://dotnetfiddle.net/NyiE3S\" rel=\"nofollow noreferrer\">DEMO</a></p>\n<p><strong>EDIT</strong></p>\n<p>I found a &quot;solution&quot; to that problem using a lot of reflection and magic field names:</p>\n<pre><code>var catalogExportProviderProperty = compositionContainer\n                                    .GetType()\n                                    .GetProperty(&quot;CatalogExportProvider&quot;, BindingFlags.Instance | BindingFlags.NonPublic) ??\n                                    throw ReflectionErrors.MissingProperty(\n                                        compositionContainer.GetType(),\n                                        &quot;CatalogExportProvider&quot;);\nvar catalogExportProvider =\n    catalogExportProviderProperty.GetValue(compositionContainer) ??\n    throw new InvalidOperationException(\n        $@&quot;Uninitialized property 'CatalogExportProvider' in {compositionContainer.GetType().Name}.&quot;);\nvar partsToDisposeField =\n    catalogExportProvider.GetType().GetField(&quot;_partsToDispose&quot;, BindingFlags.Instance | BindingFlags.NonPublic) ??\n    throw ReflectionErrors.MissingField(catalogExportProvider.GetType(), &quot;_partsToDispose&quot;);\nvar partsToDispose = partsToDisposeField.GetValue(catalogExportProvider) as IEnumerable ??\n                     throw new InvalidOperationException($@&quot;Unable to retrieve disposable parts from {catalogExportProvider.GetType()}.&quot;);\nforeach (var item in partsToDispose.OfType&lt;object&gt;())\n{\n    var cachedInstanceProperty = item.GetType().GetProperty(&quot;CachedInstance&quot;, BindingFlags.Instance | BindingFlags.NonPublic) ??\n                                 throw ReflectionErrors.MissingProperty(item.GetType(), &quot;CachedInstance&quot;);\n    var cachedInstance = cachedInstanceProperty.GetValue(item, index: null);\n    if (cachedInstance is IAsyncDisposable asyncDisposable)\n    {\n        await asyncDisposable.DisposeAsync();\n    }\n}\n</code></pre>\n<p>This works because there is an <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-disposeasync\" rel=\"nofollow noreferrer\">implementation specification</a> that every type that implements <code>IAsyncDisposable</code> should also implement <code>IDisposable</code>.</p>\n<p>BUT: This solution doesn't feel right. I'm still looking for an official solution to that problem.</p>\n", "acceptedAnswer": "<p>I found a solution by implementing a <code>CustomCompositionContainer</code>.</p>\n<p>The following points were taken into account:</p>\n<p><code>Export</code></p>\n<ul>\n<li>In this class, the instances are retrieved via the <code>GetExportedValueCore</code> method, which can be overwritten.</li>\n<li>A wrapper is created that overwrites the above-mentioned method and provides information via a callback.</li>\n</ul>\n<p><code>CompositionContainer</code></p>\n<ul>\n<li>The <code>GetExportsCore</code> method can be overwritten. This is used to retrieve all exports of this <code>CompositionContainer</code>.\n<ul>\n<li>MEF also uses this to resolve dependencies.</li>\n</ul>\n</li>\n<li>In this context, <code>Export</code> instances are returned.</li>\n<li>In <code>GetExportsCore</code>, the existing <code>Export</code> instances are packed into the wrapper, which is then able to provide information about the instances.</li>\n</ul>\n<p>This derivation of <code>CompositionContainer</code> provides access to all retrieved, shared instances:</p>\n<pre><code>public class CustomCompositionContainer : CompositionContainer\n{\n    private readonly ConcurrentDictionary&lt;object, object?&gt; _retrievedSharedExports = new(ObjectReferenceEqualityComparer&lt;object&gt;.Default);\n\n    public CustomCompositionContainer(ComposablePartCatalog? catalog, CompositionOptions compositionOptions, params ExportProvider[]? providers)\n        : base(catalog, compositionOptions, providers)\n    {\n    }\n\n    public IEnumerable&lt;object&gt; RetrievedSharedExports =&gt; this._retrievedSharedExports.Keys;\n\n    protected override IEnumerable&lt;Export&gt;? GetExportsCore(ImportDefinition definition, AtomicComposition? atomicComposition)\n    {\n        var exports = base.GetExportsCore(definition, atomicComposition);\n        if (exports is null)\n        {\n            yield break;\n        }\n\n        foreach (var item in exports)\n        {\n            if ((CreationPolicy?)item.Metadata.GetValueOrDefault(&quot;System.ComponentModel.Composition.CreationPolicy&quot;) == CreationPolicy.Shared)\n            {\n                yield return new VerboseExport(item, OnExportedValueRetrieved);\n                continue;\n            }\n\n            yield return item;\n        }\n\n        void OnExportedValueRetrieved(object exportedValue) =&gt; this._retrievedSharedExports.TryAdd(exportedValue, null);\n    }\n\n    private sealed class VerboseExport : Export\n    {\n        private readonly Export _target;\n\n        private readonly Action&lt;object&gt; _onExportedValueRetrieved;\n\n        public VerboseExport(Export target, Action&lt;object&gt; onExportedValueRetrieved)\n        {\n            target.ThrowIfNull();\n            onExportedValueRetrieved.ThrowIfNull();\n\n            this._target = target;\n            this._onExportedValueRetrieved = onExportedValueRetrieved;\n        }\n\n        public override ExportDefinition Definition =&gt; this._target.Definition;\n\n        protected override object? GetExportedValueCore()\n        {\n            var result = this._target.Value;\n            if (result is not null)\n            {\n                this._onExportedValueRetrieved(result);\n            }\n\n            return result;\n        }\n    }\n}\n</code></pre>\n<p>The solution created above can now be simplified to the following code:</p>\n<pre><code>foreach (var item in compositionContainer.RetrievedSharedExports.OfType&lt;IAsyncDisposable&gt;())\n{\n    await item.DisposeAsync().ConfigureAwait(false);\n}\n</code></pre>\n<p>This might not be the best solution but it's much cleaner than the previously used one that uses reflection for MEF internal types.</p>\n", "questionSource": "https://stackoverflow.com/questions/72045065/mef-vs-iasyncdisposable-or-iterate-over-all-instantiated-exports"}