[
    {
        "Title": "How to solve ArrayIndexOutOfBoundsException: Index 2048 out of bounds for length 2048 in AndroidStudio",
        "Question": "I were working and building successfully each time.\nSuddenly it's showing this message: Index 2048 out of bounds for length 2048\nIt shows only when I click to run on AVD. Beside this, during the build time it builds successfully.\nIt also should be noted that, I am using the updated version of Android Studio and my codes are in kotlin. Can anyone solve this issue?\n\nExecution failed for task ':app:parseDebugLocalResources'.\n> A failure occurred while executing com.android.build.gradle.internal.res.ParseLibraryResourcesTask$ParseResourcesRunnable\n   > Failed to parse XML resource file 'F:\\Android\\IndiaTubeBd\\app\\build\\intermediates\\packaged_res\\debug\\values\\values.xml'\n\n* Try:\n> Run with --info or --debug option to get more log output.\n> Run with --scan to get full insights.\n> Get more help at https://help.gradle.org.\n\n* Exception is:\norg.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:parseDebugLocalResources'.\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$1(ExecuteActionsTaskExecuter.java:149)\n    at org.gradle.internal.Try$Failure.ifSuccessfulOrElse(Try.java:282)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:147)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)\n    at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\n    at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\n    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\n    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\n    at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n    at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\n    at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\n    at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)\n    at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)\n    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\n    at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:47)\nCaused by: org.gradle.workers.internal.DefaultWorkerExecutor$WorkExecutionException: A failure occurred while executing com.android.build.gradle.internal.res.ParseLibraryResourcesTask$ParseResourcesRunnable\n    at org.gradle.workers.internal.DefaultWorkerExecutor$WorkItemExecution.waitForCompletion(DefaultWorkerExecutor.java:283)\n    at org.gradle.internal.work.DefaultAsyncWorkTracker.lambda$waitForItemsAndGatherFailures$2(DefaultAsyncWorkTracker.java:130)\n    at org.gradle.internal.Factories$1.create(Factories.java:31)\n    at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLocks(DefaultWorkerLeaseService.java:321)\n    at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLocks(DefaultWorkerLeaseService.java:304)\n    at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLock(DefaultWorkerLeaseService.java:309)\n    at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForItemsAndGatherFailures(DefaultAsyncWorkTracker.java:126)\n    at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForItemsAndGatherFailures(DefaultAsyncWorkTracker.java:92)\n    at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForAll(DefaultAsyncWorkTracker.java:78)\n    at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForCompletion(DefaultAsyncWorkTracker.java:66)\n    at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:256)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\n    at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:68)\n    at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:233)\n    at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:216)\n    at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:199)\n    at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:166)\n    at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\n    at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\n    at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\n    at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n    at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\n    at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\n    at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\n    at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\n    at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\n    at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)\n    at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)\n    at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\n    at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:50)\n    at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:28)\n    at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.executeDelegateBroadcastingChanges(CaptureStateAfterExecutionStep.java:100)\n    at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:72)\n    at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:50)\n    at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\n    at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\n    at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:179)\n    at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:70)\n    at org.gradle.internal.Either$Right.fold(Either.java:175)\n    at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:59)\n    at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:68)\n    at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:46)\n    at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:36)\n    at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:25)\n    at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)\n    at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)\n    at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:91)\n    at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:55)\n    at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)\n    at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:37)\n    at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\n    at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\n    at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\n    at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\n    at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:77)\n    at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:38)\n    at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:94)\n    at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:49)\n    at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:71)\n    at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:45)\n    at org.gradle.internal.execution.steps.SkipEmptyWorkStep.executeWithNonEmptySources(SkipEmptyWorkStep.java:177)\n    at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:81)\n    at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:53)\n    at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:32)\n    at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:21)\n    at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\n    at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\n    at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\n    at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:75)\n    at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:41)\n    at org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:32)\n    at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:293)\n    at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)\n    at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:21)\n    at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)\n    at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)\n    at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:47)\n    at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:34)\n    at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:64)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:146)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)\n    at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\n    at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\n    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\n    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\n    at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n    at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\n    at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\n    at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)\n    at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\n    at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)\n    at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)\n    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\n    at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:47)\nCaused by: com.android.ide.common.symbols.ResourceDirectoryParseException: Failed to parse XML resource file 'F:\\Android\\IndiaTubeBd\\app\\build\\intermediates\\packaged_res\\debug\\values\\values.xml'\n    at com.android.ide.common.symbols.ResourceDirectoryParser.parseResourceFile(ResourceDirectoryParser.kt:191)\n    at com.android.ide.common.symbols.ResourceDirectoryParser.parseResourceDirectory(ResourceDirectoryParser.kt:151)\n    at com.android.ide.common.symbols.ResourceDirectoryParser.parseResourceSourceSetDirectory(ResourceDirectoryParser.kt:102)\n    at com.android.build.gradle.internal.res.ParseLibraryResourcesTaskKt.doFullTaskAction(ParseLibraryResourcesTask.kt:228)\n    at com.android.build.gradle.internal.res.ParseLibraryResourcesTask$ParseResourcesRunnable.run(ParseLibraryResourcesTask.kt:147)\n    at com.android.build.gradle.internal.profile.ProfileAwareWorkAction.execute(ProfileAwareWorkAction.kt:74)\n    at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)\n    at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)\n    at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)\n    at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)\n    at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)\n    at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)\n    at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n    at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n    at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\n    at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)\n    at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)\n    at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:170)\n    at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:187)\n    at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:120)\n    at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:162)\n    at org.gradle.internal.Factories$1.create(Factories.java:31)\n    at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:249)\n    at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:109)\n    at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:114)\n    at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:157)\n    at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:126)\n    ... 2 more\nCaused by: java.lang.ArrayIndexOutOfBoundsException: Index 2048 out of bounds for length 2048\n    at org.apache.xerces.impl.io.UTF8Reader.read(Unknown Source)\n    at org.apache.xerces.impl.XMLEntityScanner.load(Unknown Source)\n    at org.apache.xerces.impl.XMLEntityScanner.scanContent(Unknown Source)\n    at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanContent(Unknown Source)\n    at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)\n    at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)\n    at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n    at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n    at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)\n    at org.apache.xerces.parsers.DOMParser.parse(Unknown Source)\n    at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source)\n    at com.android.ide.common.symbols.ResourceDirectoryParser.parseResourceFile(ResourceDirectoryParser.kt:186)\n    ... 34 more\n\n\nBUILD FAILED in 999ms\n25 actionable tasks: 4 executed, 21 up-to-date\n\n\n\nThanks in advance for solving this.\n\nI have removed every unused XML layout files.\nI have comment-blocked a few codes inserted at the last stage.\n\nBut, still now I have not found.\nI think, this problem is for any XML file.\n",
        "Answer": "Finally I have made the solution.\nI have opened the strings.xml file in Notepad++ outside of the Android Studio. I found that, while generating strings containing SPACEBAR or special chars, it includes a double quote sign. Screenshot attached bellow:\n\nThen I have closed the Android studio, and removed each extra double quotes from each string files by Notepad++. After saving this, I have re-opened Android Studio and now it runs perfectly.\n\n",
        "Source": "https://stackoverflow.com/questions/77710158/how-to-solve-arrayindexoutofboundsexception-index-2048-out-of-bounds-for-length"
    },
    {
        "Title": "A confusing exception out of bound error in java while solving a spiral 2d matrix question",
        "Question": "I was solving this question, trying to generate spiral matrix but repeatedly getting error only when the length of the matrix is odd. It is working fine when the length is even\nThis is the code:\npublic class spiral {\n    public static void main(String[] args) {\n        int n = 5;\n        generateSpiralMat(n);\n    }\n\n    static void generateSpiralMat(int n) {\n        int[][] mat = new int[n][n] ;\n        int topRow =0, rightCol = n-1, bottonRow = n-1, leftCol = 0 ;\n        int num = 1 ;\n\n        while( num < n*n + 1 ) {\n            //topRow -> leftCol to rightCol\n            for(int i=leftCol; i<rightCol; i++) {\n                mat[topRow][i] = num;\n                num ++ ;\n            }\n\n            //rightCol -> topRow to bottomRow\n            for(int j =topRow; j<bottonRow; j++){\n                mat[j][rightCol] = num ;\n                num++ ;\n            }\n\n            //bottomRow -> rightCol to leftCol\n            for(int i=rightCol; i> leftCol; i--) {\n                mat[bottonRow][i] = num;\n                num++ ;\n            }\n\n            //leftCol -> bottomRow to topRow\n            for(int j=bottonRow; j>topRow; j--) {\n                mat[j][leftCol] = num ;\n                num ++ ;\n            }\n\n            topRow += 1 ;\n            bottonRow -= 1 ;\n            leftCol += 1 ;\n            rightCol -= 1 ;\n        }\n\n        printMat(mat);\n    }\n\n    static void printMat(int[][] mat) {\n        for(int i=0; i< mat.length; i++) {\n            for(int j=0; j< mat[i].length; j++) {\n                System.out.print( mat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\nEven length matrix working well but code is showing error in runtime only for odd length matrix\nI was expecting that the code would generate a spiral matrix as per the given question.\n",
        "Answer": "void spiral( int side ) {\n   int matriz[][] = new int[ side ][ side ];\n   int length = side * side;\n   int count = 0;\n   int top = side - 1;\n   int floor = 0;\n   int sector = 0;\n   int j = 0, k = 0;\n   for( int i = 0; i < length; i++ ) { \n      matriz[ j ][ k ] = count;\n      switch( sector ) {\n         case 3: j--;\n            if( j == floor ) {\n               sector = 0;\n               top -= 1;\n            }\n            break;\n         case 2: k--;\n            if( k == floor ) {\n               floor++;\n               sector++;\n            }\n            break;\n         case 1: j++;\n            if( j == top ) {\n               sector++;\n            }\n            break;\n         case 0: k++;\n            if( k == top ) {\n               sector++;\n            }\n            break; \n      }\n      count++;\n   } \n}\n\nWe divide the operation into four stages:\nA) advance in the columns\nB) advance in the rows\nC) back in the columns\nD) back in rows\nwhen it reaches the corresponding limit, it goes to the next sector, in sector \"3\" the upper limit is modified, and in \"2\" the lower limit.\n",
        "Source": "https://stackoverflow.com/questions/77027038/a-confusing-exception-out-of-bound-error-in-java-while-solving-a-spiral-2d-matri"
    },
    {
        "Title": "Return keyword in void method not always working JAVA",
        "Question": "I am coding with Java a function that checks if a date it's ok or not and want to jump up of the method if some condition is executed.\nI've read a similar question but hasn't the same trouble as it occurs in general and that's not what I want to ask.\npublic static void validar(String data) {\n\n        System.out.println (data);\n\n        if (data.indexOf(\" \") == -1) {\n            System.out.println (\"No hi ha separaci\u00f3 entre data i temps\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n        else if (data.indexOf(\"-\") == -1) {\n            System.out.println (\"La data no cont\u00e9 un guions\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n        else if (data.indexOf(\":\") == -1) {\n            System.out.println (\"El temps de la data no cont\u00e9 :'s\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n\n        ...\n\nIt all works when done like this it:\n2023-01-17 17:05:26\nData correcta\n\n2023-01-1717:05:26\nNo hi ha separaci\u00f3 entre data i temps\nData incorrecta\n\n2023/01-17 17.05.26\nEl temps de la data no cont\u00e9 :'s\nData incorrecta\n\n2023-01-17 17.05.26\nEl temps de la data no cont\u00e9 :'s\nData incorrecta\n\nHave other conditions to check related to the date (if the date's length is 3 and the same for the time and much more) so I've created some array.\nIf I create them in the middle of the conditions like:\nif (data.indexOf(\" \") == -1) {\n            System.out.println (\"No hi ha separaci\u00f3 entre data i temps\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n        else if (data.indexOf(\"-\") == -1) {\n            System.out.println (\"La data no cont\u00e9 un guions\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n        else if (data.indexOf(\":\") == -1) {\n            System.out.println (\"El temps de la data no cont\u00e9 :'s\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n\n        String[] arrDiaHora = data.split(\" \");\n        String diamesany = arrDiaHora[0];\n        String horaminutsegon = arrDiaHora[1];\n\n        String[] arrDiaMesAny = diamesany.split(\"-\");\n        String strany = arrDiaMesAny[0];\n        String strmes = arrDiaMesAny[1];\n        String strdia = arrDiaMesAny[2];\n\n        String[] arrHoraMinutSegon = horaminutsegon.split(\":\");\n        String strhora = arrHoraMinutSegon[0];\n        String strminut = arrHoraMinutSegon[1];\n        String strsegon = arrHoraMinutSegon[2];\n\n        if (arrDiaHora.length != 2) {\n            System.out.println (\"No hi ha dos blocs formats per data i temps\");\n            System.out.println (\"Data incorrecta\" + \"\\n\");\n            return;\n        }\n        \n        ...\n\nReturn values after the arrays don't work and get 'return' is unnecessary as the last statement in a 'void' method.\nIf I create the arrays before checking the conditions, I got an ArrayIndexOutOfBoundsException\nAny help ?\nThanks in advance !!\n",
        "Answer": "The other answer nicely describes better ways to validate dates.\nIMHO it fails to address your concern: why does IntelliJ IDEA report \"'return' is unnecessary as the last statement in a 'void' method.\" on some of your return statements?\nTo explain that, I simplified your example to this:\npublic static void validar(int n) {\n    System.out.println(n);\n\n    if (n == 3) {\n        System.out.println(\"a\");\n        return;  // Note 1\n    } else if (n == 5) {\n        System.out.println(\"b\");\n        return;  // Note 1\n    }\n\n    int x = n * n;\n\n    if (x == 4) {\n        System.out.println(\"c\");\n        return;  // Note 2\n    } else if (x == 16) {\n        System.out.println(\"c\");\n        return;  // Note 2\n    }\n\n}\nI've added two notices to the return statements:\nNote 1: the return; statements at these places is needed to exit early from the method. Without these return; statements the rest of the method would also execute. Accordingly there is no report from IntelliJ IDEA at these\nNote 2: there are no more statements that could possibly be executed after these return; statements. They are therefore unnecessary. They are the last statements in the branches of an if - else if chain and there are no more statements after that chain. That means that execution of the method ends after executing the preceding statement anyway. For these return; statements IntelliJ IDEA reports \"'return' is unnecessary as the last statement in a 'void' method.\".\nPlease note that this is an informational message: its intention is to help you write better (cleaner) code. It doesn't mean that your code is faulty (i.e. it doesn't mean your code will not compile or will have bugs in it.)\nYou can change that simplified code (without changing its observable behaviour) to\npublic static void validar(int n) {\n    System.out.println(n);\n\n    if (n == 3) {\n        System.out.println(\"a\");\n        return;  // Note 1\n    } else if (n == 5) {\n        System.out.println(\"b\");\n        return;  // Note 1\n    }\n\n    int x = n * n;\n\n    if (x == 4) {\n        System.out.println(\"c\");\n    } else if (x == 16) {\n        System.out.println(\"c\");\n    }\n\n}\n",
        "Source": "https://stackoverflow.com/questions/76226815/return-keyword-in-void-method-not-always-working-java"
    },
    {
        "Title": "ArrayIndexOutOfBoundsException in assistedViewModel after upgrading",
        "Question": "@Keep\n@Composable\n@InternalCoroutinesApi\n@ExperimentalCoroutinesApi\nfun SetupNavigationHost(\n    navController: NavHostController,\n) {\n\n    NavHost(\n        navController = navController,\n        startDestination = Screen.MainScreen.route,\n    )\n    {\n        composable(\n            Screen.MainScreen.route,\n            deepLinks = listOf(navDeepLink { uriPattern = Screen.MainScreen.deepLinkRoute })\n        ) {\n            HomeScreen(\n                navController = navController\n            )\n        }\n\n\n        composable(\n            Screen.ShowTimeslotDetails.route,\n            arguments = listOf(\n                navArgument(\"id\") {}\n            )\n        ) { backStackEntry ->\n            backStackEntry.arguments?.getString(\"id\")\n                ?.let {\n                    val viewModel: TimeslotViewModel = assistedViewModel {\n                        TimeslotViewModel.provideFactory(timeslotViewModelFactory(), it.toInt())\n                    }\n                    ShowTimeslotDetails(\n                        timeslotId = it.toInt(),\n                        viewModel = viewModel,\n                        navController = navController\n                    )\n                }\n        }\n\n\n    }\n}\n\nThe error happens in this line:\nassistedViewModel {\n   TimeslotViewModel.provideFactory(timeslotViewModelFactory(), it.toInt())\n}\n\nviewModel:\n@Module\n@InstallIn(ActivityRetainedComponent::class)\ninterface AssistedInjectModule\n\nclass TimeslotViewModel @AssistedInject constructor(\n    @Assisted private val timeslotId: Int,\n) : ViewModel() {\n\n   @AssistedFactory\n    interface Factory {\n        fun create(timeslotId: Int): TimeslotViewModel\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    companion object {\n        fun provideFactory(factory: Factory, id: Int): ViewModelProvider.Factory {\n            return object : ViewModelProvider.Factory {\n                override fun <T : ViewModel> create(modelClass: Class<T>): T {\n                    return factory.create(id) as T\n                }\n            }\n        }\n    }\n\n}\n\nMainActivity\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n\n    @EntryPoint\n    @InstallIn(ActivityComponent::class)\n    interface ViewModelFactoryProvider {\n        fun timeslotViewModelFactory(): TimeslotViewModel.Factory\n    }\n...\n}\n\nError:\nFATAL EXCEPTION: main\nProcess: com.example.versions10, PID: 20465\njava.lang.ArrayIndexOutOfBoundsException: length=109; index=-1\nat java.util.ArrayList.remove(ArrayList.java:506)\nat androidx.compose.runtime.Stack.pop(Stack.kt:26)\nat androidx.compose.runtime.ComposerImpl.exitGroup(Composer.kt:2246)\nat androidx.compose.runtime.ComposerImpl.end(Composer.kt:2408)\nat androidx.compose.runtime.ComposerImpl.endGroup(Composer.kt:1578)\nat androidx.compose.runtime.ComposerImpl.endRoot(Composer.kt:1462)\nat androidx.compose.runtime.ComposerImpl.doCompose(Composer.kt:3367)\nat androidx.compose.runtime.ComposerImpl.recompose$runtime_release(Composer.kt:3307)\nat androidx.compose.runtime.CompositionImpl.recompose(Composition.kt:772)\nat androidx.compose.runtime.Recomposer.performRecompose(Recomposer.kt:1047)\nat androidx.compose.runtime.Recomposer.access$performRecompose(Recomposer.kt:124)\nat androidx.compose.runtime.Recomposer$runRecomposeAndApplyChanges$2$2.invoke(Recomposer.kt:541)\nat androidx.compose.runtime.Recomposer$runRecomposeAndApplyChanges$2$2.invoke(Recomposer.kt:510)\nat androidx.compose.ui.platform.AndroidUiFrameClock$withFrameNanos$2$callback$1.doFrame(AndroidUiFrameClock.android.kt:34)\nat androidx.compose.ui.platform.AndroidUiDispatcher.performFrameDispatch(AndroidUiDispatcher.android.kt:109)\nat androidx.compose.ui.platform.AndroidUiDispatcher.access$performFrameDispatch(AndroidUiDispatcher.android.kt:41)\nat androidx.compose.ui.platform.AndroidUiDispatcher$dispatchCallback$1.doFrame(AndroidUiDispatcher.android.kt:69)\nat android.view.Choreographer$CallbackRecord.run(Choreographer.java:1299)\nat android.view.Choreographer$CallbackRecord.run(Choreographer.java:1309)\nat android.view.Choreographer.doCallbacks(Choreographer.java:923)\nat android.view.Choreographer.doFrame(Choreographer.java:847)\nat android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:1283)\nat android.os.Handler.handleCallback(Handler.java:942)\nat android.os.Handler.dispatchMessage(Handler.java:99)\nat android.os.Looper.loopOnce(Looper.java:226)\nat android.os.Looper.loop(Looper.java:313)\nat android.app.ActivityThread.main(ActivityThread.java:8741)\nat java.lang.reflect.Method.invoke(Native Method)\nat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:571)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1067)\nSuppressed: kotlinx.coroutines.DiagnosticCoroutineContextException: \\[androidx.compose.runtime.PausableMonotonicFrameClock@cb194e5, androidx.compose.ui.platform.MotionDurationScaleImpl@1185bba, StandaloneCoroutine{Cancelling}@f2dea6b, AndroidUiDispatcher@dbb99c8\\]\n\nThis error happens after making these upgrades (worked fine before the upgrade):\n\nkotlinCompilerExtensionVersion = \"1.4.3\"\njvmTarget = \"17\"\nsourceCompatibility = JavaVersion.VERSION_17\ntargetCompatibility = JavaVersion.VERSION_17\nid(\"org.jetbrains.kotlin.android\") version   \"1.8.10\" apply false\nid(\"com.android.application\") version \"8.1.0-alpha11\" apply false\nthe source code is here:\nhttps://github.com/CsharpGamer/Update10\n\n",
        "Answer": "The bug is fixed in android studio 2022.3.1 Beta 1\n",
        "Source": "https://stackoverflow.com/questions/75941435/arrayindexoutofboundsexception-in-assistedviewmodel-after-upgrading"
    },
    {
        "Title": "Is it possible to get the value of an ArrayIndexOutOfBoundsException in Java?",
        "Question": "I'm trying to do a program which uses a matrix and makes a new one with each element being the sum of every adjacent element of the original one plus itself.\nIt's very easy to understand that the \"edge\" values of the matrix, if you access them by the matrix indexes, then you may be getting something like matrix[-1][0]. The thing is, Java throws an exception so the program crashes.\nIs it possible to catch it and get the value it has anyway? Even if it's not initialized, because the thing is that mathematically you can multiply by 0 the whole term when it's accessing an out of bound address.\npublic class OpMatriz {\n\n    public static void main(String[] args) {\n        \n        int[][] miMatriz= {{1,9,10,7,2,1,9},{-5,1,9,10,7,2,1},{2,1,3,1,5,2,11}};\n        imprimeMatriz(miMatriz);\n        \n        miMatriz = OpMatriz.sumaAdyacentes(miMatriz);\n        \n        imprimeMatriz(miMatriz);\n        \n\n    }\n    \n    public static int[][] sumaAdyacentes(int[][] matriz){\n        \n        int n = matriz.length;\n        int m = matriz[0].length;\n        \n        int[][] matrizAux = new int[n+2][m+2];\n        int[][] matrizRes = new int[n][m];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                matrizAux[i+1][j+1] = matriz[i][j];\n            }\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                matrizRes[i-1][j-1] = matrizAux[i-1][j] + matrizAux[i][j+1] + matrizAux[i+1][j] + matrizAux[i][j-1] + matrizAux[i][j];\n            }\n        }\n        \n        return matrizRes;\n    }\n    \n    public static void imprimeMatriz(int[][] matriz) {\n        for (int i = 0; i < matriz.length; i++) {\n            System.out.print(\"| \");\n            for (int j = 0; j < matriz[0].length; j++) {\n                System.out.printf(\"%2d \", matriz[i][j]);\n            }\n            System.out.println(\"|\");\n        }\n        System.out.println();\n    }\n    \n\n}\n\nMy current program just makes a \"intermediate\" matrix a bit bigger than the original, all initialized in 0, so it can add it for the edge cases. Now, I don't want to use any conditional, as it's the idea of the exercise to improve the algorithm.\nmatrizRes[i][j] = i * matriz[i-1][j] + (m+1-j) * matriz[i][j+1] + (n+1-i) * matriz[i+1][j] + j *matriz[i][j-1] + matriz[i][j];\n\nMy idea is using an equation like this, so when a term is trying to use an invalid index, whatever value it has, it's going to get multiplied by 0. So doing this, i can just not use this \"intermediate\" matrix and work it out with just the original.\nSo, finally again, is there a way to get the value of an ArrayIndexOutOfBoundsException even if it's not initialized?\nPD: Sorry for Spanish programming, it's for a university assignment.\n",
        "Answer": "Looks like you want to know the bounds or more information on Exceptions.\nBut we must not catch the exception and perform logic around it. It is not recommended.\nBut if you still want to know the information about the exception. The exception message is quite descriptive. You can use e.getMessage()\nHere is an example of e.getMessage().\nIndex 3 out of bounds for length 3\n\nTo find the bounds we can parse the error message. Here is an example.\n    int[][] matrix = new int[3][];\n    try {\n      int assign[] = matrix[3];\n    } catch (IndexOutOfBoundsException e) {\n      System.out.println(e.getMessage());\n      Stream<MatchResult> matchResultStream = Pattern.compile(\"\\\\d+\").matcher(e.getMessage()).results();\n      List<String> matchResults = matchResultStream.map(x -> x.group()).collect(Collectors.toList());\n      if (matchResults.size() > 1) {\n        System.out.println(\"Error Index \" + matchResults.get(0));\n        System.out.println(\"Max Index Bounds \" + matchResults.get(1));\n      }\n    }\n\nOutput:\n\n    Index 3 out of bounds for length 3\n    Error Index 3\n    Max Index Bounds 3\n\n\n",
        "Source": "https://stackoverflow.com/questions/73481015/is-it-possible-to-get-the-value-of-an-arrayindexoutofboundsexception-in-java"
    },
    {
        "Title": "Where is the problem in code for which I am facing Array Index out of Bounds problem?",
        "Question": "I am facing a problem in Merge Sort coded in Java language. Please can you see where I am wrong because I am facing Index out of bounds problem.\nI am sharing the code. Please check !\nThe error in the output box is :\n\n\"Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\"\n\nCode :\ncode\nimport java.util.Arrays;\n\npublic class Sorting {\n\n    public static void main(String[] args) {\n        int[] arr = {5,3,4,7,2,8,6,9,1};\n        mergesort(arr);\n    }\n\n\nstatic void mergesort(int[] arr){\n\n        mergesortalgorithm(arr,0, arr.length);\n        System.out.println(\"The sorted array is :\" + Arrays.toString(arr));\n    }\n    static void mergesortalgorithm(int[] arr,int lb,int ub){\n        if (lb < ub){\n            int mid = (lb + ub)/2;\n            mergesortalgorithm(arr,lb,mid);\n            mergesortalgorithm(arr,mid + 1,ub);\n            merge(arr,lb,mid,ub);\n        }\n    }\n    static void merge(int[] arr,int lb,int mid,int ub){\n        int i = lb;\n        int j = mid + 1;\n        int k = 0;\n        int[] newarray = new int[lb + ub];\n        while (i <= mid && j <= ub){\n            if (arr[i] <= arr[j]){\n                newarray[k] = arr[i];\n                i++;\n            }\n            else {\n                newarray[k] = arr[j];\n                j++;\n            }\n            k++;\n        }\n        if (i > mid){\n            while (j <= ub){\n                newarray[k] = arr[j];\n                j++;\n                k++;\n            }\n        }\n        else {\n            while (i <= mid){\n                newarray[k] = arr[i];\n                i++;\n                k++;\n            }\n        }\n        for (int l = lb;l <= ub;l++){\n            arr[l] = newarray[l];\n        }\n    }\n}\n\n",
        "Answer": "ArrayIndexOutOfBoundsException is an exception thrown when you try to reach an item of an array using an invalid index that is outside its bounds.\nAn array of an elements has its first element indexed as 0, the second as 1 and so on, the last index being n - 1.\nSo, let's say you have an array of int[] arr = {5,3,4,7,2,8,6,9,1}, which is of 9 elements. This means that trying to reach an element having a negative index (such as arr[-4]) or trying to reach any items of it beyond 8 (such as arr[9] or arr[234]) will throw an `ArrayIndexOutOfBoundsException.\nA very simple way to get past such errors is to find the exact line where it is occurring, like\nnewarray[k] = arr[i];\n\nand seeing that when k becomes 1, then newarray, which has a single element cannot reference it, as it has a single element, having an index of 0. So, in order to get past this issue one is tempted to add safety checks that ensure that you never get past the boundaries, such as\nwhile ((i <= mid && j <= ub) && (i < arr.length) && (j < arr.length)){\n\neventually reaching to the syntactically correct\nstatic void merge(int[] arr,int lb,int mid,int ub){\n    int i = lb;\n    int j = mid + 1;\n    int k = 0;\n    int[] newarray = new int[lb + ub];\n    while ((i <= mid && j <= ub) && (i < arr.length) && (j < arr.length)){\n        if (arr[i] <= arr[j]){\n            newarray[k] = arr[i];\n            i++;\n        }\n        else {\n            newarray[k] = arr[j];\n            j++;\n        }\n        k++;\n    }\n    if (i > mid){\n        while ((j <= ub) && (k < newarray.length) && (j < arr.length)){\n            newarray[k] = arr[j];\n            j++;\n            k++;\n        }\n    }\n    else {\n        while ((i <= mid) && (k < newarray.length)){\n            newarray[k] = arr[i];\n            i++;\n            k++;\n        }\n    }\n    for (int l = lb;(l <= ub) && (l < newarray.length) && (l < arr.length);l++){\n        arr[l] = newarray[l];\n    }\n}\n\n, but this only copes with the syntactical issues and does not scratch the logical problem that you have and will yield the incorrect [0, 0, 0, 0, 0, 0, 3, 3, 0] as the result. So, clearly, your problem does not consist in getting the index out of bounds exception, it's only the symptom. The actual problem is in the logic.\nSo, you have some assumption that's faulty. But what it could be? For starters, you have this line:\nmergesortalgorithm(arr,0, arr.length);\n\nThink about this line: the first item is the 0'th, while the last item is the arr.length'th item. How many items do you have here? A total of arr.length + 1 items. This means that you will definitely get out of bounds when you refer the last item. So, you need to fix your logic and at the end you will most probably not even need for syntactic safety checks if your algorithm is guaranteed to work inside the proper bounds. The line above should be changed to\nmergesortalgorithm(arr,0, arr.length - 1);\n\nAlso, you will need to keep track of how your indexes are changed, especially k and how exactly you implemented the algorithm.\n",
        "Source": "https://stackoverflow.com/questions/72763576/where-is-the-problem-in-code-for-which-i-am-facing-array-index-out-of-bounds-pro"
    },
    {
        "Title": "Codingbat challenge: zeroFront Stream API Solution",
        "Question": "Given the task zeroFront notAlone from CodingBat:\n\nReturn an array that contains the exact same numbers as the given\narray, but rearranged so that all the zeros are grouped at the start\nof the array.\nThe order of the non-zero numbers does not matter. So\n{1, 0, 0, 1} becomes {0 ,0, 1, 1}. You may modify and return the\ngiven array or make a new array.\n\nzeroFront([1, 0, 0, 1])      \u2192   [0, 0, 1, 1]\nzeroFront([0, 1, 1, 0, 1])   \u2192   [0, 0, 1, 1, 1]\nzeroFront([1, 0])            \u2192   [0, 1]\n\nMy solution to this problem throws an ArrayIndexOutOfBoundsException in some cases:\npublic int[] zeroFront(int[] nums) {\n  if (nums.length == 0) {\n    return nums;\n  }\n  \n  int[] zeroFront = new int[nums.length];\n  int zeroCounter = 0;\n  \n  for (int i = 0; i < zeroFront.length; i++) {\n    if (nums[i] == 0) {\n      zeroCounter++;\n    }\n  }\n  \n  for (int i = 0; i < zeroCounter; i++) {\n    zeroFront[i] = 0;\n  }\n  \n   \n  for (int i = 0; i < nums.length; i++) {\n    if (nums[i] != 0) {\n      zeroFront[zeroCounter + i] = nums[i];\n    }\n  }\n  \n  return zeroFront;\n}\n\nMy questions are the following:\nWhat can be done in order to fix my solution?\nHow is it possible to solve this task using Stream API ?\n",
        "Answer": "The index of zeroFront is incorrect. It should not be zeroCounter + i, but rather zeroCounter + nonZeroCounter, where nonZeroCounter is the number of non-zeroes seen so far. Note that this is no equal to i, which is the total number of all zeroes and non-zeroes seen so far.\nTo fix it, just keep another count of the non-zeroes:\nint nonZeroCount = 0;\nfor (int num : nums) {\n    if (num != 0) {\n        zeroFront[zeroCounter + nonZeroCount++] = num;\n    }\n}\n\nAlso note that the loop to set the first nonZeroCounter elements of zeroFront to 0 is not necessary. The elements of an int array are initialised to 0 automatically.\nFor the stream solution, you can make use of the fact that false is ordered before true, and sort the array by x != 0:\npublic static int[] zeroFrontStreams(int[] nums) {\n    return Arrays.stream(nums).boxed().sorted(Comparator.comparing(x -> x != 0)).mapToInt(x -> x).toArray();\n}\n\nBut note that since this involves sorting, its time complexity is worse compared to your O(n) solution. There is also much boxing/unboxing involved.\nAlternatively, if you just want to use streams somewhere in your code, you can use it to separate the array into zeroes and non-zeroes, then copy the non-zeroes to the tail of zeroFront in some other way:\npublic static int[] zeroFrontStreams(int[] nums) {\n    var partitions = Arrays.stream(nums).boxed().collect(Collectors.partitioningBy(x -> x == 0));\n    int[] zeroFront = new int[nums.length];\n    int[] nonZeros = partitions.get(false).stream().mapToInt(x -> x).toArray();\n    int zeroCounter = partitions.get(true).size();\n    System.arraycopy(nonZeros, 0, zeroFront, zeroCounter, nonZeros.length);\n    return zeroFront;\n}\n\nWithout (un)boxing, but with some code duplication of Arrays.stream(nums).filter:\npublic static int[] zeroFront(int[] nums) {\n    int[] zeroFront = new int[nums.length];\n    long zeroCounter = Arrays.stream(nums).filter(x -> x == 0).count();\n    int[] nonZeros = Arrays.stream(nums).filter(x -> x != 0).toArray();\n    System.arraycopy(nonZeros, 0, zeroFront, (int)zeroCounter, nonZeros.length);\n    return zeroFront;\n}\n\n",
        "Source": "https://stackoverflow.com/questions/72584902/codingbat-challenge-zerofront-stream-api-solution"
    },
    {
        "Title": "Unable to start activity: java.lang.ArrayIndexOutOfBoundsException",
        "Question": "Everyone, hi!\nFriends, when you click on the button, a new activity does not start. The following exception occurs: java.lang.ArrayIndexOutOfBoundsException.\nThe log of my error is presented below:\nE/AndroidRuntime: FATAL EXCEPTION: main\n    Process: com.example.projectMP3, PID: 3228\n    java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.projectMP3/com.example.projectMP3.Activity.PlayerActivity}: java.lang.ArrayIndexOutOfBoundsException: length=12; index=-1\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2400)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2458)\n        at android.app.ActivityThread.access$900(ActivityThread.java:172)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1305)\n        at android.os.Handler.dispatchMessage(Handler.java:102)\n        at android.os.Looper.loop(Looper.java:146)\n        at android.app.ActivityThread.main(ActivityThread.java:5598)\n        at java.lang.reflect.Method.invokeNative(Native Method)\n        at java.lang.reflect.Method.invoke(Method.java:515)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1283)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1099)\n        at dalvik.system.NativeStart.main(Native Method)\n     Caused by: java.lang.ArrayIndexOutOfBoundsException: length=12; index=-1\n        at java.util.ArrayList.get(ArrayList.java:310)\n        at com.example.projectMP3.Activity.PlayerActivity.getIntentMethod(PlayerActivity.java:167)\n        at com.example.projectMP3.Activity.PlayerActivity.onCreate(PlayerActivity.java:62)\n        at android.app.Activity.performCreate(Activity.java:5459)\n        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1093)\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2364)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2458)\u00a0\n        at android.app.ActivityThread.access$900(ActivityThread.java:172)\u00a0\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1305)\u00a0\n        at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\n        at android.os.Looper.loop(Looper.java:146)\u00a0\n        at android.app.ActivityThread.main(ActivityThread.java:5598)\u00a0\n        at java.lang.reflect.Method.invokeNative(Native Method)\u00a0\n        at java.lang.reflect.Method.invoke(Method.java:515)\u00a0\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1283)\u00a0\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1099)\u00a0\n        at dalvik.system.NativeStart.main(Native Method)\u00a0\n\nProgram code for MainActivity.java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener {\n //....\n private void int_viewPager() {\n\n        ViewPager viewPager;\n        TabLayout tabLayout;\n        FloatingActionButton openMusicPlayer;\n        //...\n        androidx.appcompat.widget.Toolbar toolbar;\n        viewPager = findViewById(R.id.view_Pager);\n        tabLayout = findViewById(R.id.tab_layout);\n        //...\n        viewPager.setAdapter(viewPagerAdapter);\n        tabLayout.setupWithViewPager(viewPager);\n\n        openMusicPlayer = findViewById(R.id.open_Music);\n        openMusicPlayer.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent intent = new Intent(MainActivity.this, PlayerActivity.class);\n                startActivity(intent);\n            }\n        });\n\n    }\n}\n\nProgram code for PlayerActivity.java:\n//...\npublic class PlayerActivity extends AppCompatActivity implements MediaPlayer.OnCompletionListener {\n   \n    /** \u041b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 (\u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435, \u043f\u043e\u0432\u0442\u043e\u0440 \u0430\u0443\u0434\u0438\u043e\u0437\u0430\u043f\u0438\u0441\u0438) */\n    static boolean shuffleBoolean = false, repeatBoolean;\n    /** \u0421\u043f\u0438\u0441\u043e\u043a \u043c\u0443\u0437\u044b\u043a\u0430\u043b\u044c\u043d\u044b\u0445 \u043a\u043e\u043c\u043f\u043e\u0437\u0438\u0446\u0438\u0439 */\n    ArrayList<MusicFile> listSong = new ArrayList<>();\n    /** \u0421\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0439 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 */\n    Uri uri;\n    /** \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u043e\u0442\u043e\u043a\u0430 - \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 */\n    Handler handler = new Handler();\n    /** \u041f\u043e\u0442\u043e\u043a\u0438 \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f */\n    Thread playThread, prevThread, nextThread;\n\n    private int position = -1;\n    private FloatingActionButton playPause;\n    //...\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // \u0420\u0430\u0437\u043c\u0435\u0449\u0430\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u043d\u0430 \u044d\u043a\u0440\u0430\u043d\u0435 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438\n        setContentView(R.layout.activity_player);\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f\n        initView();\n        // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 Intent\n        getIntentMethod();\n\n        /* \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c listener, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\n        *  \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0435, \u043a\u043e\u0433\u0434\u0430 \u043f\u0440\u043e\u0438\u0433\u0440\u044b\u0432\u0430\u043d\u0438\u0435 \u0437\u0430\u043a\u043e\u043d\u0447\u0438\u0442\u0441\u044f. */\n        mediaPlayer.setOnCompletionListener(this);\n\n        //...\n\n        // \u041f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0432 \u0444\u043e\u043d\u043e\u0432\u044b\u0439 \u0440\u0435\u0436\u0438\u043c\n        PlayerActivity.this.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n               //...\n        });  \n    }\n\n  \n    /** \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0438\u044f (Intent) */\n    private void getIntentMethod() {\n        /* \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435, \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0435 \u0440\u0430\u043d\u0435\u0435\n        *  \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e putExtra() */\n        position = getIntent().getIntExtra(\"position\", -1);\n        String sender =  getIntent().getStringExtra(\"Sender\");\n\n        if(sender!= null && sender.equals(\"albumDetails\")) {\n            listSong = album_Music;\n        } else {\n            listSong = musicFilesSongAdapter;\n        }\n\n        if (listSong != null) {\n            playPause.setImageResource(R.drawable.ic_pause);\n            uri = Uri.parse(listSong.get(position).getPath());\n        }\n\n        if (mediaPlayer != null) {\n            mediaPlayer.stop();\n            // \u041e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u043f\u0440\u0438\u043e\u0431\u0440\u0435\u0442\u0435\u043d\u043d\u044b\u0435 \u0440\u0435\u0441\u0443\u0440\u0441\u044b (\u043f\u0430\u043c\u044f\u0442\u044c, \u043a\u043e\u0434\u0435\u043a\u0438)\n            mediaPlayer.release();\n        }\n        mediaPlayer = MediaPlayer.create(getApplicationContext(), uri);\n        mediaPlayer.start();\n        songSeekBar.setMax(mediaPlayer.getDuration() / 1000);\n        metaData(uri);\n    }\n\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435 (\u0430\u043b\u044c\u0431\u043e\u043c \u0438 \u0434\u0440.)\n    private void metaData(Uri uri) {\n       //...\n    }\n \n    private void prevThreadBtn() {\n        prevThread = new Thread() {\n            @Override\n            public void run() {\n                super.run();\n                playPrev.setOnClickListener(v -> prevBtnClicked());\n            }\n        };\n        prevThread.start();\n    }\n\n    /** \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043d\u0430\u0436\u0430\u0442\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 (Play previous)*/\n    private void prevBtnClicked() {\n        if (mediaPlayer.isPlaying()) {\n            /* \u041e\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435,\n            * \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u0440\u0435\u0441\u0443\u0440\u0441\u044b, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u0441 \u044d\u0442\u0438\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u043c */\n            mediaPlayer.stop();\n            mediaPlayer.release();\n\n            /* \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u044b \u043b\u0438 \u0440\u0435\u0436\u0438\u043c\u044b Shuffle, Repeat */\n            if (shuffleBoolean && !repeatBoolean) {\n                position = getRandom(listSong.size() - 1);\n            } else if (!shuffleBoolean && !repeatBoolean) {\n                position = ((position - 1) < 0 ? (listSong.size() - 1) : (position - 1));\n            }\n\n            uri = Uri.parse(listSong.get(position).getPath());\n            // \u0421\u043e\u0437\u0434\u0430\u0435\u043c MediaPlayer \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0433\u043e URI\n            mediaPlayer = MediaPlayer.create(getApplicationContext(), uri);\n            // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043c\u0435\u0442\u0430\u0434\u0430\u043d\u043d\u044b\u0435\n            metaData(uri);\n            //...\n  }\n\n    /** \u0412\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u0432\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438\n     *  (after onResume() has been called) */\n    @Override\n    protected void onPostResume() {\n        playThreadBtn();\n        prevThreadBtn();\n        nextThreadBtn();\n        super.onPostResume();\n    }\n\n\n    /** \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0441\u0441\u044b\u043b\u043a\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f */\n    private void initView() {\n        songName = findViewById(R.id.song_name);\n        durationPlayed = findViewById(R.id.duration_played);\n        totalDuration = findViewById(R.id.duration_total);\n        //...\n    }\n\n   \n    @Override\n    public void onCompletion(MediaPlayer mp) {\n       //...\n    }\n}\n\nIf I understand correctly, then the error is in the following lines:\nif (listSong != null) {\n            playPause.setImageResource(R.drawable.ic_pause);\n            uri = Uri.parse(listSong.get(position).getPath());\n        }\n\nBut... I do not know how to fix the error. Could you help?\n",
        "Answer": "it is because your position is -1, you must check\nif(position != -1)\n    uri = Uri.parse(listSong.get(position).getPath());\n\nyou have not send position when starting activity\nIntent intent = new Intent(MainActivity.this, PlayerActivity.class);\nstartActivity(intent);\n\n",
        "Source": "https://stackoverflow.com/questions/71953386/unable-to-start-activity-java-lang-arrayindexoutofboundsexception"
    },
    {
        "Title": "Append swing jbutton elements to array in java",
        "Question": "I am working on a messaging application. The GUI is written in Java Swing. When the client starts, it asks my server for the chats a specific user is involved in. The server will send these in the form of an string array eg: {CHAT_PATH,CHAT_PATH}.\nOnce the client receives this it feeds it to my GUI class, which is supposed to display each chat name in the list (I will filter out the rest of the path) on screen listed downward. This is where my problem lies. I start by creating a JButton list:\nJButton[] chat_names = {};\n\nand then I loop through the list of chats (chat_data) and add to my chat_names list a new JButton for each chat name. Like this:\nfor (int x=0; x<chat_data.length-1; x++){\n    chat_names[x] = new JButton(chat_data[x]);\n    chat_names[x].setBounds(100,100,100,100);\n}\n    \nfor (int x=0; x<chat_names.length; x++){\n    frame.add(chat_names[x]);\n}\n\nWhen I do this I get the following syntax error:\nException in thread \"main\" \njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of   \nbounds for length 0\nat gui_main.menu_screen(gui_main.java:16)\nat Main.main(Main.java:89)\n\nDoes anyone know if this is fixable or another way I could display a list of buttons each with a chat_name on them.\n",
        "Answer": "Here you created an array of JButtons with length 0\nJButton[] chat_names = {};\n\nYou can either call\nchat_names = new JButton[chat_data.length]; \n\nbefore the for-loops or create a\nList<JButton> chatNames = new ArrayList<>();\n\nto have a variable length list of buttons\nAs a tip use camelCase rather than snake_case for your variables and methods, as that's the convention.\nAnd one more thing don't manually specify the bounds of each JButton, instead use a proper Layout Manager for example GridLayout or BoxLayout may work. If you insist on using setBounds and (more than surely) null-layout you may find yourself in a problem similar to this one when trying to run it on a different computer or a different monitor.\nYou can also merge these 2 loops:\nfor (int x=0; x<chat_data.length-1; x++){\n    chat_names[x] = new JButton(chat_data[x]);\n    chat_names[x].setBounds(100,100,100,100);\n}\n    \nfor (int x=0; x<chat_names.length; x++){\n    frame.add(chat_names[x]);\n}\n\nInto one, reducing one iteration over all the chats and thus improving performance:\nfor (int x=0; x<chat_data.length-1; x++){\n    chat_names[x] = new JButton(chat_data[x]);\n    chat_names[x].setBounds(100,100,100,100); //Use a layout manager!\n    frame.add(chat_names[x]);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/70452159/append-swing-jbutton-elements-to-array-in-java"
    },
    {
        "Title": "ArrayIndexOutOfBound error when i used enhanced for loop",
        "Question": "Can we use enhanced for loop without getting ArrayIndexOutOfBound error.\nbecause after using normal for loop it is working.\n    public static void main(String[] args) {\n        int a[] = {1,2,3,4};\n        int b[] = {1,2,3,4};\n boolean status = true;\n        if (a.length == b.length){\n            for (int i:a){\n                if (a[i] != b[i]){\n                    status =false;\n                }\n            }\n        }\n        else {\n            status = false;\n        }\n\n        if (status == true){\n            System.out.println(\"arrays are equal...\");\n        }\n        else {\n            System.out.println(\"arrays not equal...\");\n        }\n    }\n}\n\n\n",
        "Answer": "That is because you are accessing the elements of array a.\nThe loop\nfor (int i : a) {\n  System.out.println(i);\n}\n\nwill print out the values: 1, 2, 3, 4.\nYou probably expected to get 0, 1, 2, 3 but that is not how the enhanced loop work.\nImprovement\nInstead of comparing the two array by hand, you can use the convenience method Arrays.equals():\npublic static void main(String[] args) {\n    int a[] = {1,2,3,4};\n    int b[] = {1,2,3,4};\n    boolean status = java.util.Arrays.equals(a, b);\n\n    if (status){\n        System.out.println(\"arrays are equal...\");\n    } else {\n        System.out.println(\"arrays not equal...\");\n    }\n}\n\n",
        "Source": "https://stackoverflow.com/questions/70108920/arrayindexoutofbound-error-when-i-used-enhanced-for-loop"
    },
    {
        "Title": "The Count of Remaining Arguments",
        "Question": "I need to create a program that takes integer command-line arguments. The first argument would be the count of the remaining arguments that are between 1 and 100 (inclusive of 1 and 100). It then prints out the count of numbers entered that are less than or equal to 50 and the count of numbers that are greater than 50 from those remaining arguments.\nThe code only works if I type 0 or 1 into the command prompt. Any other value returns an ArrayIndexOutOfBoundsException. I thought if I set my array equal to \"count\", it would return however many numbers I typed out when printing my code, but it's still not working.\nCan anyone make suggestions to my existing code block? I'm a novice programmer, so I'm at a loss at where to start. I've tried changing the array value around but keep getting the same error.\npublic class Distribution100 {\n  public static void main(String[] args) {\n\n    int count = Integer.parseInt(args[0]);\n\n    int[] array = new int[count];\n\n    int low = 0;\n    int high = 0;\n    for (int i = 0; i < count; i++) {\n\n      array[i] = Integer.parseInt(args[i]);\n\n      if (array[i] >= 1 && array[i] <= 50) {\n        low++;\n      } else if (array[i] > 50 && array[i] <= 100) {\n        high++;\n      }\n    }\n\n    System.out.println(low + \" numbers are less than or equal to 50.\");\n\n    System.out.println(high + \" numbers are higher than 50.\");\n\n  }\n\n}\n\n",
        "Answer": "This code worked for me. Notice that I've changed one line from your code - you had array[i] = Integer.parseInt(args[i]);, and I changed it to array[i] Integer.parseInt(args[i + 1]);, as i starts at 0 and args[0] is your count, not one of the numbers to check.\npublic static void main(String[] args) {\n\n        int count = Integer.parseInt(args[0]);\n\n        int[] array = new int[count];\n\n        int low = 0;\n        int high = 0;\n        for (int i = 0; i < count; i++) {\n\n            array[i] = Integer.parseInt(args[i + 1]);\n\n            if (array[i] >= 1 && array[i] <= 50) {\n                low++;\n            } else if (array[i] > 50 && array[i] <= 100) {\n                high++;\n            }\n        }\n\n        System.out.println(low + \" numbers are less than or equal to 50.\");\n\n        System.out.println(high + \" numbers are higher than 50.\");\n\n    }\n\n",
        "Source": "https://stackoverflow.com/questions/69274593/the-count-of-remaining-arguments"
    },
    {
        "Title": "App crashes on putting more than 28 &#39;composable&#39; element inside AnimatedNavHost (Jetpack Compose)",
        "Question": "My app is a single activity app with different screens represented by composables. I am using navigation component to handle screen navigation.\nMy navigation component has AnimatedNavHost as:\nAnimatedNavHost(\n            navController = navController,\n            startDestination = Constants.SPLASH,\n            enterTransition = { initial, _ ->\n                slideInHorizontally(initialOffsetX = { 1000 })\n\n            },\n            exitTransition = { _, target ->\n                slideOutHorizontally(targetOffsetX = { -1000 })\n\n            },\n            popEnterTransition = { initial, _ ->\n\n                slideInHorizontally(initialOffsetX = { -1000 })\n\n            },\n\n            popExitTransition = { _, target ->\n\n                slideOutHorizontally(targetOffsetX = { 1000 })\n\n            }\n\n        ) {\n            composable(Constants.SPLASH) {\n                Splash(navController = navController)\n\n\n            }\n            composable(Constants.HIW) {\n\n                LogoPage(\n                    false,\n                    true,\n                    navController = navController\n                ) { HowItWorks(navController = navController, false) }\n\n.\n.\n.\n\n//Other 26 'composable' elements\n}\n\nWhen I add even 1 more 'composable' element, my app crashes, and the logcat says:\n java.lang.ArrayIndexOutOfBoundsException: length=29; index=29\n        at androidx.collection.SparseArrayCompat.valueAt(SparseArrayCompat.java:379)\n        at androidx.navigation.NavController.setGraph(NavController.kt:948)\n        at androidx.navigation.NavController.setGraph(NavController.kt:95)\n        at com.google.accompanist.navigation.animation.AnimatedNavHostKt.AnimatedNavHost(AnimatedNavHost.kt:146)\n        at com.google.accompanist.navigation.animation.AnimatedNavHostKt.AnimatedNavHost(AnimatedNavHost.kt:85)\n\nHow do I solve this?\nBeen trying a lot of things, but not able to solve.\nAlso, there doesn't seem to be any online information regarding this.\nPlease help!\n",
        "Answer": "It is reported in this issue.\n\nRelNote: \"There will no longer be an ArrayIndexOutOfBoundsException\nwhen calling setGraph with a graph with 13 or 29 destinations.\"\n\nIt should be fixed with Navigation 2.4.0-alpha08\n",
        "Source": "https://stackoverflow.com/questions/69087861/app-crashes-on-putting-more-than-28-composable-element-inside-animatednavhost"
    },
    {
        "Title": "ArrayIndexOutOfBoundsException when Creating LinearLayout",
        "Question": "Hello? I am debugging some issue related with Android widget.\nMy app is using two thread provided by Glide library to make original widget image file and thumbnail widget image file.\nWhen Making a widget image file, My app create some layout like a LinearLayout and draw it in a bitmap (ex) layout.draw(Canvas(bitmap))) and save bitmap into a file.\nIt works fine in almost time, but some issues are reported like below sometimes.\njava.lang.ArrayIndexOutOfBoundsException: length=3; index=3\n  at android.util.ContainerHelpers.binarySearch(ContainerHelpers.java:28)\n  at android.util.SparseArray.get(SparseArray.java:120)\n  at android.util.SparseArray.get(SparseArray.java:111)\n  at android.view.ViewConfiguration.get(ViewConfiguration.java:494)\n  at android.view.View.<init>(View.java:5432)\n  at android.view.View.<init>(View.java:5624)\n  at android.view.ViewGroup.<init>(ViewGroup.java:687)\n  at android.widget.LinearLayout.<init>(LinearLayout.java:254)\n  at android.widget.LinearLayout.<init>(LinearLayout.java:250)\n  at android.widget.LinearLayout.<init>(LinearLayout.java:246)\n  at android.widget.LinearLayout.<init>(LinearLayout.java:242)\n\nThis Exception is thrown when I just make a LinearLayout like this LinearLayout(context).apply { orientation = LinearLayout.VERTICAL }\nI suspect some Concurrency. Is there any problem with creating LinearLayout in Multithread?\n",
        "Answer": "Link to the full answer.\nIf shortly - the issue is inside of SparseArray. Try to update the library to the latest version OR temporarily downgrade the version and watch for updates.\n",
        "Source": "https://stackoverflow.com/questions/69068736/arrayindexoutofboundsexception-when-creating-linearlayout"
    },
    {
        "Title": "Randomized QuickSort IndexOutOfBounds exception",
        "Question": "this is the QuickSort Randomized that I've come up with, but it constantly throws out IndexOutOfBounds exception. Could I have some help with it? Thanks!\nimport java.util.Random;\n\npublic class QuickSort {\n\n    void quickSort(int[] A, int start, int end) { // Initially: start = 0, end = n-1\n        while (start < end) {\n            int iOfPartition = randomisedPartition(A, start, end);\n            if (iOfPartition - start < end - iOfPartition) {\n                quickSort(A, start, iOfPartition - 1);\n                start = iOfPartition + 1;\n            } else {\n                quickSort(A, iOfPartition + 1, end);\n                end = iOfPartition - 1;\n            }\n        }\n    }\n\n    int randomisedPartition(int[] A, int start, int end) {\n        Random rng = new Random();\n        int randomNum = rng.nextInt(end + 1 - start) + start;\n        swap(A, A[randomNum], A[start]);\n        return hoarePartition(A, start, end);\n    }\n\n    int hoarePartition(int[] A, int start, int end) {\n        int pivot = A[start];\n        int i = start;\n        int j = end;\n        while (i < j) {\n            while (A[i] <= pivot && i < end) i++;\n            while (A[j] > pivot && j > start) j--;\n            if (i < j) swap(A, A[i], A[j]); \n        }\n        swap(A, A[start], A[j]);\n        return j; \n    }\n\n    void swap(int[] A, int i, int j) {\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n}\n\nI keep getting an arrayindexoutofbounds error.\n",
        "Answer": "I echo the sentiment of the comment above, you should learn to use the debugger or print statements to try to piece together what is happening.\nStill, I couldn't resist investigating.\nCheck out what you are doing here in the call to swap. You are taking the value which is in the randomNum position with A[randomNum]\n    swap(A, A[randomNum], A[start]); // incorrectly indexing here\n\nBut then inside swap, you are repeating the process, and taking the value at the A[A[randomNum]] which does not necessarily exist.\nint temp = A[i]; // indexing here again\n\nSo your problem is that you are incorrectly indexing twice. You should use [] only in the swap function, not in the randomisedPartition function. randomisedPartition should send swap indexes, not indexed values.\nHow did I figure this out ?\nI tried a call with very simple data\nint data[] = {5,3,4};\nnew Example().quickSort(data, 0, 2);\n\nand got an index out of bounds 5 error. That's how you debug.\n",
        "Source": "https://stackoverflow.com/questions/68940699/randomized-quicksort-indexoutofbounds-exception"
    },
    {
        "Title": "Got ArrayIndexOutOfBoundException when not out of bound",
        "Question": "I'm writing an implementation for AES with 128 bit key. An exception is thrown at the last line of the else block.\n    private static int KEY_SIZE_IN_BYTE = 16;\n    private static int EXPANDED_KEY_SIZE_IN_BYTE = 176;\n    private static int BYTE_PER_WORD = 4;\n\nprivate static byte[][] doKeyExpansion(byte[] keyByteArray) {\n        int keySizeInWord = KEY_SIZE_IN_BYTE / BYTE_PER_WORD;\n        int expandedKeySizeInWord = EXPANDED_KEY_SIZE_IN_BYTE / BYTE_PER_WORD;\n        \n        byte[][] result = new byte[expandedKeySizeInWord][BYTE_PER_WORD];\n        \n        for(int i = 0; i < keySizeInWord; i++) {\n            for(int j = 0; j < BYTE_PER_WORD; j++) {\n                result[i][j] = keyByteArray[i * BYTE_PER_WORD + j];\n            }\n        }\n        \n        for(int i = keySizeInWord; i < expandedKeySizeInWord; i++) {\n            byte[] temp = new byte[BYTE_PER_WORD];\n            \n            // Rotate word if 4 divides i\n            if(i % 4 == 0) {\n                for(int j = 0; j < BYTE_PER_WORD; j++) {\n                    temp[j] = result[i - 1][(j + 1) % BYTE_PER_WORD];\n                }\n            } else {\n                for(int j = 0; j < BYTE_PER_WORD; j++) {\n                    byte a = result[i - 1][j];\n                    temp[j] = 1;\n                    byte b = 5;\n                    temp[j] = b;\n\n                    // Exception is thrown if this is not commented\n                    //temp[j] = a;\n                }\n            }\n            \n            // Substitute using Sbox\n            for(int j = 0; j < BYTE_PER_WORD; j++) {\n                temp[j] = substitueWithSbox(temp[j]);\n            }\n            \n            // xor round constant\n            byte[] roundConstant = { (byte) ROUND_CONSTANT_FIRST_BYTE[(i / BYTE_PER_WORD) - 1], 0, 0, 0}; \n            temp = xorWord(temp, roundConstant);\n            \n            result[i] = xorWord(temp, result[i - 4]);\n        }\n        \n        return result;\n    }\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n\nWhen I comment it out like this, the code runs fine without problem.\nI attempted to separate them out like a few lines above, and both sides of the assignments don't trigger any exception. I don't know why this happen.\nCould somebody help please?\nI add this so it could help provide detail of the situation. Line 83 throws an excpetion if line 87 is not commented (Thanks to @tgdavies that he corrected me on this). Comment it out and it will work. This is the most confusing thing that I've seen so far.\nimport java.util.BitSet;\n\npublic class Duplicate {\n    \n    private static byte HEX_BASE = 16;\n\n    private static int KEY_SIZE_IN_BYTE = 16;\n\n    private static int EXPANDED_KEY_SIZE_IN_BYTE = 176;\n    private static int BYTE_PER_WORD = 4;\n\n    \n    private static int[] SBOX = {\n            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n            };\n    \n    private static int[] ROUND_CONSTANT_FIRST_BYTE = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 };\n\n    public static void main(String[] args) {\n        String plaintextExample = \"0123456789abcdeffedcba9876543210\".toUpperCase();\n        String keyExample = \"0f1571c947d9e8590cb7add6af7f6798\".toUpperCase();\n        String ciphertextExample = \"ff0b844a0853bf7c6934ab4364148fb9\".toUpperCase();\n        \n        String plaintextExample2 = \"0023456789abcdeffedcba9876543210\".toUpperCase();\n        String ciphertextExample2 = \"612b89398d0600cde116227ce72433f0\".toUpperCase();\n        \n        byte[] keyByteArray = convertKeyToByteArray(keyExample);\n        byte[][] expandedKey = doKeyExpansion(keyByteArray);\n        \n//      for(int i = 0; i < 44; i++) {\n//          for(int j = 0; j < 4; j++) {\n//              System.out.print(Integer.toHexString(Byte.toUnsignedInt(expandedKey[i][j])));\n//          }\n//      }\n        \n        System.out.println(\"Done\");\n    }\n    \n    private static void testByteArray(byte[] toTest) {\n        for(int i = 0; i < toTest.length; i++) {\n            System.out.print(toTest[i]);\n        }\n        System.out.println();\n    }\n\n    private static byte[][] doKeyExpansion(byte[] keyByteArray) {\n        int keySizeInWord = KEY_SIZE_IN_BYTE / BYTE_PER_WORD;\n        int expandedKeySizeInWord = EXPANDED_KEY_SIZE_IN_BYTE / BYTE_PER_WORD;\n        \n        byte[][] result = new byte[expandedKeySizeInWord][BYTE_PER_WORD];\n        \n        for(int i = 0; i < keySizeInWord; i++) {\n            for(int j = 0; j < BYTE_PER_WORD; j++) {\n                result[i][j] = keyByteArray[i * BYTE_PER_WORD + j];\n            }\n        }\n        \n        for(int i = keySizeInWord; i < expandedKeySizeInWord; i++) {\n            byte[] temp = new byte[BYTE_PER_WORD];\n            \n            // Rotate word if 4 divides i\n            if(i % 4 == 0) {\n                for(int j = 0; j < BYTE_PER_WORD; j++) {\n                    temp[j] = result[i - 1][(j + 1) % BYTE_PER_WORD];\n                }\n            } else {\n                for(int j = 0; j < BYTE_PER_WORD; j++) {\n                    byte a = result[i - 1][j];    // line 83\n                    temp[j] = 1;\n                    byte b = 5;\n                    temp[j] = b;\n                    temp[j] = a;    // line 87\n                }\n            }\n            \n            // Substitute using Sbox\n            for(int j = 0; j < BYTE_PER_WORD; j++) {\n                temp[j] = substitueWithSbox(temp[j]);\n            }\n            \n            // xor round constant\n            byte[] roundConstant = { (byte) ROUND_CONSTANT_FIRST_BYTE[(i / BYTE_PER_WORD) - 1], 0, 0, 0}; \n            temp = xorWord(temp, roundConstant);\n            \n            result[i] = xorWord(temp, result[i - 4]);\n        }\n        \n        return result;\n    }\n\n    private static byte[] xorWord(byte[] byteArray1, byte[] byteArray2) {\n        byte[] result;\n        BitSet bitSet = new BitSet(byteArray1.length * 8);\n        \n        for(int i = 0; i < byteArray1.length; i++) {\n            int unsignedByte1 = Byte.toUnsignedInt(byteArray1[i]);\n            int unsignedByte2 = Byte.toUnsignedInt(byteArray2[i]);\n            for(int j = 0; j < 8; j++) {\n                bitSet.set(i * 8 + j, unsignedByte1 % 2 != unsignedByte2 % 2);\n                unsignedByte1 /= 2;\n                unsignedByte2 /= 2;\n            }\n        }\n        \n        result = bitSet.toByteArray();\n        return result;\n    }\n\n    private static byte substitueWithSbox(byte b) {\n        int temp = Byte.toUnsignedInt(b);\n        return (byte) SBOX[temp];\n    }\n\n    private static byte[] convertKeyToByteArray(String keyExample) {\n        byte[] result = new byte[KEY_SIZE_IN_BYTE];\n        \n        for(int i = 0; i < keyExample.length(); i += 2) {\n            result[i/2] = convertHexBlockToByte(keyExample.substring(i, i+2));\n        }\n        \n        return result;\n    }\n\n    private static byte convertHexBlockToByte(String hexBlock) {\n        return (byte) (convertHexDitgitToDecimal(hexBlock.charAt(0)) * HEX_BASE +\n                            convertHexDitgitToDecimal(hexBlock.charAt(1)));\n    }\n\n    private static byte convertHexDitgitToDecimal(char hexDigit) {\n        byte result = 0;\n        \n        switch(hexDigit) {\n        case '0':\n            result = 0;\n            break;\n        case '1':\n            result = 1;\n            break;\n        case '2':\n            result = 2;\n            break;\n        case '3':\n            result = 3;\n            break;\n        case '4':\n            result = 4;\n            break;\n        case '5':\n            result = 5;\n            break;\n        case '6':\n            result = 6;\n            break;\n        case '7':\n            result = 7;\n            break;\n        case '8':\n            result = 8;\n            break;\n        case '9':\n            result = 9;\n            break;\n        case 'A':\n            result = 10;\n            break;\n        case 'B':\n            result = 11;\n            break;\n        case 'C':\n            result = 12;\n            break;\n        case 'D':\n            result = 13;\n            break;\n        case 'E':\n            result = 14;\n            break;\n        case 'F':\n            result = 15;\n            break;\n        }\n        \n        return result;\n    }\n\n}\n\n",
        "Answer": "Run this little program, but first try to predict what it will print. Then think about your xorWord function:\npublic class BitSetEg {\n    public static void main(String... args) {\n        BitSet b = new BitSet(32);\n\n        byte[] bytes = b.toByteArray();\n        System.out.println(bytes.length);\n    }\n}\n\n",
        "Source": "https://stackoverflow.com/questions/68425126/got-arrayindexoutofboundexception-when-not-out-of-bound"
    },
    {
        "Title": "Checking adjacent cells in a java ArrayList for minesweeper",
        "Question": "I have all my cells stored in an ArrayList and I want to check how many mines they are surrounded by (mines are cells with a not null mine png). I thought of checking the positions -1, +1, -9, +9, -10, +10, -11, +11 relative to each cell and add 1 to a counter inside the cell object. Problem is I get out of bounds and don\u00b4t know how to avoid it.\nfor (Cell cell: cells){\n        if ((cells.get(cells.indexOf(cell) - 1).mine != null)&&((cells.indexOf(cell) - 1) >= 0)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) + 1).mine != null)&&((cells.indexOf(cell) + 1) < 100)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) - 10).mine != null)&&((cells.indexOf(cell) - 10) >= 0)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) + 10).mine != null)&&((cells.indexOf(cell) + 10) < 100)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) - 11).mine != null)&&((cells.indexOf(cell) - 11) >= 0)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) + 11).mine != null)&&((cells.indexOf(cell) + 11) < 100)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) - 9).mine != null)&&((cells.indexOf(cell) - 9) >= 0)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n        if ((cells.get(cells.indexOf(cell) + 9).mine != null)&&((cells.indexOf(cell) + 9) < 100)) {\n            cell.setMine_number(cell.getMine_number() + 1);\n        }\n    }\n\nIgnore the spaghetti code I always refactor when things work.\n",
        "Answer": "\nI thought of checking the positions -1, ...\n\nThat thought doesn't work unfortunately.\nFirst of all, you \"hardcode\" the dimension of your \"supposedly 2 dim\" list into these numbers. What if you change the grid to 20x20. Then -10 is meaningless.\nThen: it is kinda obvious that for plenty of slots, -10 or +10 wont work.\nYou could create a simple checker method like:\nboolean isValidIndex(int cellIndex, int offset) {\n  // not doing your homework for you, but rest assured\n  // this method is easy to implement\n\nthat you then use like:\nif (isValidIndex(cells.indexOf(cell), 9))\n\nfor example.\n",
        "Source": "https://stackoverflow.com/questions/67498406/checking-adjacent-cells-in-a-java-arraylist-for-minesweeper"
    },
    {
        "Title": "Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0 with RMI",
        "Question": "I have three java files one is RMI server and RMI client and interface file, as follow:\nserver:\nimport java.rmi.*;\nimport java.rmi.registry.*;\nimport java.rmi.server.*;\nimport java.net.*;\n\npublic class RmiServer extends \n  java.rmi.server.UnicastRemoteObject implements ReceiveMessageInterface{\n  String address;\n  Registry registry; \n\n  public void receiveMessage(String x) throws RemoteException{\n  System.out.println(x);\n  }\n  \n  public RmiServer() throws RemoteException{\n  try{  \n  address = (InetAddress.getLocalHost()).toString();\n  }\n  catch(Exception e){\n  System.out.println(\"can't get inet address.\");\n  }\n  int port=3233; \n  System.out.println(\"this address=\" + address +  \",port=\" + port);\n  try{\n  registry = LocateRegistry.createRegistry(port);\n  registry.rebind(\"rmiServer\", this);\n  }\n  catch(RemoteException e){\n  throw e;\n  }\n  }\n  static public void main(String args[]){\n  try{\n  RmiServer s = new RmiServer();\n  }\n  catch (Exception e){\n  e.printStackTrace();\n  System.exit(1);\n  }\n  }\n}\n\nclient:\nimport java.rmi.*;\nimport java.rmi.registry.*;\n\nimport java.net.*;\n\npublic class RmiClient{\n  static public void main(String args[]){\n  ReceiveMessageInterface rmiServer;\n  Registry registry;\n  String serverAddress=args[0];\n  String serverPort=args[1];\n  String text=args[2];\n  System.out.println\n   (\"sending \" + text + \" to \" +serverAddress + \":\" + serverPort);\n  try{\n  registry=LocateRegistry.getRegistry\n  (serverAddress,(new Integer(serverPort)).intValue());\n  rmiServer=(ReceiveMessageInterface)(registry.lookup(\"rmiServer\"));\n  // call the remote method\n  rmiServer.receiveMessage(text);\n  }\n  catch(RemoteException e){\n  e.printStackTrace();\n  }\n  catch(NotBoundException e){\n  e.printStackTrace();\n  }\n  }\n}\n\ninterface:\nimport java.rmi.*;\n\npublic interface ReceiveMessageInterface extends Remote{\n  void receiveMessage(String x) throws RemoteException;\n}\n\nso basically, when i run the server it will give my laptop address and port that is running in and this is working very well\nhowever, the problem is when i run the client after i run the server it keep throwing this error:\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException:\nIndex 0 out of bounds for length 0\n\nwhich client file in where this line:\nString serverAddress=args[0];\n\n",
        "Answer": "If you look at the method \"static public void main(String args[])\", String args[] is a standard convention.  You should pass values to this array at the command line when you invoke your program in the manner you have used.\nThe reason for your exception is, you don't have args[0] in your array as you have not passed a value. Make sure to pass three values via the command line when you invoke the program as you have accessed args[0], args[1], and args[2] in your program.\nExample :\npublic class X{\n    public static void main (String[] args) {\n        for (String s: args) {\n            System.out.println(s);\n        }\n    }\n}\n\nHow to run\njava X a ab abc\nExpected outcome\na\nab\nabc\n",
        "Source": "https://stackoverflow.com/questions/67429453/exception-in-thread-main-java-lang-arrayindexoutofboundsexception-index-0-out"
    },
    {
        "Title": "Primefaces 10 dataTable p:dataExporter generate ArrayIndexOutOfBoundsException on render after migration",
        "Question": "Environment:\n\nJboss 7.2\nPrimefaces 10\nJava 11\n\nI have migrated from primefaces 8 to primefaces 10 dataTable p:dataExporter generate ArrayIndexOutOfBoundsException on render the xhtml.\nWhen I comment out dataexporter the xhtml render well.\nFollowing the migration guide the only important change seems to be taht PDF library has been switched from iText to Libre OpenPDF.\nI've tried two differents contexts and one works and one not, differences:\n\nThe context that it works, does not have authentication\nThe context that it does not work, have keycloack authentication and two themes dependencies.\n\nI don't think is related with primefaces themes but it could be because of keycloak as it shows handeling request in log error.\nAny reason why is giving this error?\nServer error\n[161.883s][info][class,load] jdk.internal.reflect.GeneratedConstructorAccessor159 source: __JVM_DefineClass__\n[161.885s][info][class,load] jdk.internal.reflect.GeneratedConstructorAccessor160 source: __JVM_DefineClass__\n[161.886s][info][class,load] javax.faces.event.ExceptionQueuedEventContext source: jar:file:/C:/desarrollo/servers/jboss-eap-7.2/modules/system/layers/base/javax/faces/api/main/jboss-jsf-api_2.3_spec-2.3.5.SP1-redhat-1.jar!/\n[161.887s][info][class,load] org.primefaces.application.exceptionhandler.ExceptionInfo source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/primefaces-10.0.0.jar\n[161.887s][info][class,load] java.lang.Throwable$WrappedPrintWriter source: jrt:/java.base\n15:25:43,304 SEVERE [org.primefaces.application.exceptionhandler.PrimeExceptionHandler] (default task-1) Index 15 out of bounds for length 15: java.lang.ArrayIndexOutOfBoundsException: Index 15 out of bounds for length 15\n    at javax.faces.api@2.3.5.SP1-redhat-1//javax.faces.component.UIComponentBase.processRestoreState(UIComponentBase.java:1439)\n    at javax.faces.api@2.3.5.SP1-redhat-1//javax.faces.component.UIComponentBase.processRestoreState(UIComponentBase.java:1460)\n    at javax.faces.api@2.3.5.SP1-redhat-1//javax.faces.component.UIViewRoot.processRestoreState(UIViewRoot.java:955)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.application.view.JspStateManagementStrategy.restoreView(JspStateManagementStrategy.java:273)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.application.StateManagerImpl.restoreView(StateManagerImpl.java:139)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.application.view.ViewHandlingStrategy.restoreView(ViewHandlingStrategy.java:123)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.application.view.FaceletViewHandlingStrategy.restoreView(FaceletViewHandlingStrategy.java:295)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.application.view.MultiViewHandler.restoreView(MultiViewHandler.java:157)\n    at javax.faces.api@2.3.5.SP1-redhat-1//javax.faces.application.ViewHandlerWrapper.restoreView(ViewHandlerWrapper.java:125)\n    at javax.faces.api@2.3.5.SP1-redhat-1//javax.faces.application.ViewHandlerWrapper.restoreView(ViewHandlerWrapper.java:125)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.lifecycle.RestoreViewPhase.execute(RestoreViewPhase.java:204)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.lifecycle.Phase.doPhase(Phase.java:100)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.lifecycle.RestoreViewPhase.doPhase(RestoreViewPhase.java:133)\n    at com.sun.jsf-impl@2.3.5.SP2-redhat-00001//com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:201)\n    at javax.faces.api@2.3.5.SP1-redhat-1//javax.faces.webapp.FacesServlet.service(FacesServlet.java:670)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129)\n    at deployment.accfor2.ear.accfor-back.war//es.caib.accfor.presentation.back.security.UserPrincipalManager.doFilter(UserPrincipalManager.java:83)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)\n    at deployment.accfor2.ear//es.caib.accfor.commons.administracio.boundary.ThemeFilter.doFilter(ThemeFilter.java:59)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)\n    at deployment.accfor2.ear.accfor-ejb.jar//es.caib.accfor.business.logging.boundary.TimeLog.doFilter(TimeLog.java:54)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)\n    at deployment.accfor2.ear.accfor-ejb.jar//es.caib.accfor.business.encoding.boundary.CharacterEncodingFilter.doFilter(CharacterEncodingFilter.java:20)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)\n    at io.opentracing.contrib.opentracing-jaxrs2@0.1.7.redhat-00001//io.opentracing.contrib.jaxrs2.server.SpanFinishingFilter.doFilter(SpanFinishingFilter.java:55)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)\n    at org.keycloak.keycloak-undertow-adapter@11.0.2//org.keycloak.adapters.undertow.UndertowAuthenticatedActionsHandler.handleRequest(UndertowAuthenticatedActionsHandler.java:66)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.handlers.DisableCacheHandler.handleRequest(DisableCacheHandler.java:33)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.security.handlers.AuthenticationConstraintHandler.handleRequest(AuthenticationConstraintHandler.java:53)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.security.ServletSecurityConstraintHandler.handleRequest(ServletSecurityConstraintHandler.java:59)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(NotificationReceiverHandler.java:50)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.deployment.GlobalRequestControllerHandler.handleRequest(GlobalRequestControllerHandler.java:68)\n    at org.keycloak.keycloak-undertow-adapter@11.0.2//org.keycloak.adapters.undertow.ServletPreAuthActionsHandler.handleRequest(ServletPreAuthActionsHandler.java:69)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.security.SecurityContextThreadSetupAction.lambda$create$0(SecurityContextThreadSetupAction.java:105)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1502)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1502)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1502)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1502)\n    at org.wildfly.extension.undertow@7.2.0.GA-redhat-00005//org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1502)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81)\n    at io.undertow.servlet@2.0.15.Final-redhat-00001//io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.Connectors.executeRootHandler(Connectors.java:360)\n    at io.undertow.core@2.0.15.Final-redhat-00001//io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830)\n    at org.jboss.threads@2.3.2.Final-redhat-1//org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)\n    at org.jboss.threads@2.3.2.Final-redhat-1//org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1985)\n    at org.jboss.threads@2.3.2.Final-redhat-1//org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1487)\n    at org.jboss.threads@2.3.2.Final-redhat-1//org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1378)\n    at java.base/java.lang.Thread.run(Thread.java:834)\n\n[161.908s][info][class,load] javax.faces.component.html.HtmlMessages$PropertyKeys source: jar:file:/C:/desarrollo/servers/jboss-eap-7.2/modules/system/layers/base/javax/faces/api/main/jboss-jsf-api_2.3_spec-2.3.5.SP1-redhat-1.jar!/\n[161.914s][info][class,load] org.primefaces.model.DefaultStreamedContent source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/primefaces-10.0.0.jar\n[161.915s][info][class,load] org.primefaces.model.DefaultStreamedContent$Builder source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/primefaces-10.0.0.jar\n[161.916s][info][class,load] es.caib.accfor.presentation.back.ResourceBean$$Lambda$1133/0x0000000801c24840 source: es.caib.accfor.presentation.back.ResourceBean\n[161.920s][info][class,load] org.apache.commons.io.IOUtils source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/commons-io-2.6.jar\n[161.920s][info][class,load] org.apache.commons.io.output.StringBuilderWriter source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/commons-io-2.6.jar\n[161.921s][info][class,load] org.apache.commons.io.output.ByteArrayOutputStream source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/commons-io-2.6.jar\n[161.922s][info][class,load] org.apache.commons.io.Charsets source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/commons-io-2.6.jar\n[161.934s][info][class,load] org.primefaces.component.graphicimage.GraphicImageRenderer$$Lambda$1134/0x0000000801c24c40 source: org.primefaces.component.graphicimage.GraphicImageRenderer\n[161.935s][info][class,load] org.primefaces.util.DynamicContentSrcBuilder source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/primefaces-10.0.0.jar\n[161.937s][info][class,load] org.primefaces.util.LimitedSizeHashMap source: vfs:/C:/desarrollo/workspace/accfor2/accfor/accfor-ear/target/accfor2/accfor-back.war/WEB-INF/lib/primefaces-10.0.0.jar\n\nPersones.xhtml\n<p:dataTable id=\"lstPersones\" var=\"item\" value=\"#{personesBean.items}\" widgetVar=\"lstPersones\"\n             selection=\"#{personesBean.selected}\" selectionMode=\"single\"\n             rowKey=\"#{item.id}\"\n             reflow=\"true\" paginatorPosition=\"bottom\" paginator=\"true\" rows=\"10\"\n             rowsPerPageTemplate=\"10,25,50,100\" emptyMessage=\"#{messages['noResultats']}\"\n             pageLinks=\"5\" lazy=\"true\"\n             paginatorTemplate=\"{CurrentPageReport} {FirstPageLink} {PageLinks} {LastPageLink} {RowsPerPageDropdown} {Exporters} {Buttons}\"\n             currentPageReportTemplate=\"#{messages['resultats']} #{messages['paginesDataList']}.\">\n\n    <p:ajax event=\"rowSelect\" listener=\"#{personesBean.onRowSelect}\"/>\n\n    <f:facet name=\"{Exporters}\">\n        <h:commandLink>\n            <p:graphicImage library=\"images/icons\" name=\"xls.png\"\n                            title=\"#{messages['exportarXLS']}\" style=\"border:0;\"/>\n            <p:dataExporter type=\"xls\" target=\"lstPersones\" fileName=\"export_persones\"/>\n        </h:commandLink>\n    </f:facet>\n    ...\n\nweb.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n...\n    <context-param>\n        <param-name>primefaces.THEME</param-name>\n        <param-value>#{themeSwitcherBean.theme}</param-value>\n    </context-param>\n    <context-param>\n        <param-name>primefaces.FONT_AWESOME</param-name>\n        <param-value>true</param-value>\n    </context-param>\n    <context-param>\n        <param-name>primefaces.CSP</param-name>\n        <param-value>true</param-value>\n    </context-param>\n    <context-param>\n        <param-name>javax.faces.STATE_SAVING_METHOD</param-name>\n        <param-value>server</param-value>\n    </context-param>\n    <context-param>\n        <param-name>javax.faces.PARTIAL_STATE_SAVING</param-name>\n        <param-value>false</param-value>\n    </context-param>\n...\n</web-app>\n\n",
        "Answer": "I finally found the problem why I could not export files with p:dataExporter.\nThe web.xml file contained the context param javax.faces.PARTIAL_STATE_SAVING defined  to false, so I commented out and I worked well!\nThe problem in web.xml\n...\n<context-param>\n    <param-name>javax.faces.PARTIAL_STATE_SAVING</param-name>\n    <param-value>false</param-value>\n</context-param>\n...\n\n",
        "Source": "https://stackoverflow.com/questions/67003623/primefaces-10-datatable-pdataexporter-generate-arrayindexoutofboundsexception-o"
    },
    {
        "Title": "2D Array work, out of bounds error, for loop,",
        "Question": "One of my school works tells us to make an 2D array, and display what is in the array. I don't know why it is saying out of bounds, and am kind of stuck. What we where tasked to do is to make, 10 student IDs and 3 tests with scores for each of them, as shown below in the first row of the Array. The for loop part was designed to move on to the next column after x reaches 3 (when the final test score is displayed).\npublic class TwoDArray {\npublic static void main(String [] args) {\n    int [] [] musicScores = { {1001, 2002, 3003, 4004, 5005,6006,7007,8008,9009,1010,},{10,7,8,9,5,10,8,7,6,9},{9,8,10,9,9,10,9,9,7,9},{8,7,8,9,8,7,8,10,8,8}};\n    int y = 0;\n    for (int x = 0; x < 4; x++) {\n        System.out.print(musicScores[x][y] + \"\\t\");\n        for (x = 3;y < 10; y++) {\n            x = 0;\n            System.out.println(\"\");\n            }\n        }\n    }\n}\n\n",
        "Answer": "Your problem is that for the line:\nSystem.out.print(musicScores[x][y] + \"\\t\");\n\nyou are allowing y to take on a value of 10, which an invalid array index.  The reason for this is that you are using y after you have exited the for loop:\nfor (y = 0;y < 10; y++) {\n    ...\n}\n\nWhen this loop exits, y is 10.  You then loop around and use y outside of that loop, which you probably shouldn't be doing.  I'm not sure exactly what you're trying to do, but maybe you want to move the problematic line inside your inner for loop, like this:\nclass TwoDArray {\n    public static void main(String [] args) {\n        int [] [] musicScores = { {1001, 2002, 3003, 4004, 5005,6006,7007,8008,9009,1010,},{10,7,8,9,5,10,8,7,6,9},{9,8,10,9,9,10,9,9,7,9},{8,7,8,9,8,7,8,10,8,8}};\n        for (int x = 0; x < 4; x++) {\n            for (int y = 0;y < 10; y++) {\n                System.out.print(musicScores[x][y] + \"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n\nNOTE: Both my answer and the one supplied by @Dren clean up your code quite a bit. Setting x = 0 was doing you no good, and if you only use y inside the inner for loop, which you probably should be doing, then its best to define y in the for loop itself to make sure you don't use it outside the loop.  All that your inner for loop is doing in your original code is printing a bunch of empty lines.  I doubt that's what you intended.  Neither of our solutions prints blank lines.\n@Dren's answer does something quite noteworthy...it replaces hard-coded constants for array lengths with the actual lengths of the arrays in your dataset.  This is always preferable.  If you do this, then when you change your dataset, you don't have to make sure you change the hard coded length values to match...something that is quite error prone.\n",
        "Source": "https://stackoverflow.com/questions/66339238/2d-array-work-out-of-bounds-error-for-loop"
    },
    {
        "Title": "&quot;Hello world&quot; exercise in c++ throws ArrayIndexOutOfBoundsException",
        "Question": "My textbook showed this piece of C++ code to run however when I run it on net beans it displays this error Exception in thread \"main\" ArrayIndexOutOfBoundsException: 0\n#include <iostream>\n\nusing namespace std;\n\nint main(void)\n{ \n  cout << \"Hello world\";\n  return 0; \n}\n\n",
        "Answer": "there is no  java.lang.ArrayIndexOutOfBoundsException in c++\nthat error is because netbeans is running another java project instead.\nrightclick on the c++ project and click on \"close others...\"\nthen you can work on the right one.\n",
        "Source": "https://stackoverflow.com/questions/65899498/hello-world-exercise-in-c-throws-arrayindexoutofboundsexception"
    },
    {
        "Title": "Why the count is not printing after for loop?",
        "Question": "After each loop count and count1 are updated. After giving inputs in Scanner, I'm not getting any output.\nScanner sc = new Scanner(System.in);\nint t = sc.nextInt(); // t=1\nwhile (t != 0) {\n    int n = sc.nextInt(); // n=5\n    int a[] = new int[n]; // a = { 1,2,5,6,7 }\n\n    for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n    }\n    int count = 0, count1 = 0;\n    for (int i = 0; i < n; i++) {\n        if ((a[i + 1] - a[i]) > 2) {\n            count++;\n        } else {\n            count1++;\n        }\n    }\n    // this doesn't get printed\n    System.out.println(count + 1 + \" \" + count1);\n\n    t--;\n}\n\n",
        "Answer": "The conditions in the following code block will result in an ArrayIndexOutOfBoundsException as when i = n - 1, if ((a[i + 1] - a[i]) > 2) will try to get an element from a[n - 1 + 1] i.e a[n] which you already know is invalid because the indices in a[] are in the range 0 to n - 1:\nfor (int i = 0; i < n; i++) {\n    if ((a[i + 1] - a[i]) > 2)\n\nYou can put it like\nfor (int i = 0; i < n -1 ; i++) {\n    if ((a[i + 1] - a[i]) > 2)\n\nAfter this correction, given below is the result of a sample run:\n1\n5\n1 2 5 6 7\n2 3\n\nIt is because count1++ gets executed for 1 2,, 5 6 and 6 7 while count++ gets executed only for 2 5.\n",
        "Source": "https://stackoverflow.com/questions/64842090/why-the-count-is-not-printing-after-for-loop"
    },
    {
        "Title": "What causes a java.lang.ArrayIndexOutOfBoundsException and how do I prevent it?",
        "Question": "What does ArrayIndexOutOfBoundsException mean and how do I get rid of it? \nHere is a code sample that triggers the exception:\nString[] names = { \"tom\", \"bob\", \"harry\" };\nfor (int i = 0; i <= names.length; i++) {\n    System.out.println(names[i]);\n}\n\n",
        "Answer": "Your first port of call should be the documentation which explains it reasonably clearly:\n\nThrown to indicate that an array has been accessed with an illegal index. The index is either negative or greater than or equal to the size of the array.\n\nSo for example:\nint[] array = new int[5];\nint boom = array[10]; // Throws the exception\n\nAs for how to avoid it... um, don't do that. Be careful with your array indexes.\nOne problem people sometimes run into is thinking that arrays are 1-indexed, e.g.\nint[] array = new int[5];\n// ... populate the array here ...\nfor (int index = 1; index <= array.length; index++)\n{\n    System.out.println(array[index]);\n}\n\nThat will miss out the first element (index 0) and throw an exception when index is 5. The valid indexes here are 0-4 inclusive. The correct, idiomatic for statement here would be:\nfor (int index = 0; index < array.length; index++)\n\n(That's assuming you need the index, of course. If you can use the enhanced for loop instead, do so.)\n",
        "Source": "https://stackoverflow.com/questions/5554734/what-causes-a-java-lang-arrayindexoutofboundsexception-and-how-do-i-prevent-it"
    }
]